{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\csgray\c0;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \CocoaLigature0 Use these guidelines to generate questions that are easy to organize. Do NOT worry about difficulty level for now. Questions are questions - ideally we will want to be able to answer all of them we come across. Keep the CLI architecture simple. Lean on /docs to help you provide context. \
\
When the app starts, ask the user for AI provider: \
\
--- AI Provider ---\
\uc0\u9675  OpenAI\
\uc0\u9675  Gemini\
\
Then prompt for an API key unless one has already been stored. Store API keys permanently once given. Test the API keys when provided and let the user know if they are ready to bill for tokens. Make it simple to add AI providers - we will likely be using more in the future. It seems like the easiest way to implement the AI-generation and feedback is with Simon Willison\'92s \'91llm\'92 project (and llm-gemini). Try to use those modules unless you can come up with a simpler architecture.  \
\
\
Here is how we want the primary menu to look:  
\f1\fs24 \cf0 \CocoaLigature1 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \CocoaLigature0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
   --- Learn ---\
   \uc0\u9675  Study Mode (Socratic Tutor)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
   \uc0\u9675  Missed Questions (2)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
   --- Drill ---\
   \uc0\u9675  Open Ended Questions (6)\
   \uc0\u9675  Basic Terminology (205)\
   \uc0\u9675  Command Syntax (105)\
   \uc0\u9675  YAML Manifest (44)\
   --- Settings ---\
   \uc0\u9675  API Keys\
   \uc0\u9675  Cluster Configuration\
   \uc0\u9675  Tool Scripts\
   \uc0\u9675  Triaged Questions\
   \uc0\u9675  Help \
   \uc0\u9675  Exit App\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\
\
Since we are drilling Kubernetes for the CKAD, all of our questions will be in YAML. They will be stored in the /yaml dir. We will use a sqlite db to track all changes to the yaml. We will perform backups of the yaml regularly. We have consolidated lists of all questions in /yaml/backups. Here is our basic schema for the questions: \
\
Question Types: \
- Open-Ended: Require AI to do fuzzy matching on an explanation - these will be entirely produced by \'91study mode\'92 and require an active AI to evaluate if \'91more or less\'92 correct. The user should be able to navigate answers with arrows easily, not creating strange karat \'93^\'94 type notations when attempting to edit their answer. The question should be graded as soon as the user hits enter on the command line. \
- Basic Terminology: Will be asking for a single command, resource type, short name, function, true/false - they are the only type can be evaluated without AI. But they will need to be generated by AI, and the app will need to be able to easily add additional ones via AI parsing. The question should be graded as soon as the user hits enter on the command line. The user should be able to navigate answers with arrows easily, not creating strange karat \'93^\'94 type notations when attempting to edit their answer. \
- Command Syntax: these will need to be literally evaluated at the command line, and will require AI support, because there will be multiple ways of solving a problem, there will be shorthand, aliases, and duplicate-purpose commands that would viably solve the problem the same as an overly static string response. These should have suggested answers, but the AI needs to override if the user provides a correct answer that is not an exact replica of what is stated in the YAML. These will be focused on frequently seen commands in Linux, Vim, Kubectl, and Helm. The question should be graded as soon as the user hits enter on the command line. The user should be able to navigate answers with arrows easily, not creating strange karat \'93^\'94 type notations when attempting to edit their answer. \
- YAML Manifest: these are going to be the most important part of this app. The declarative approach of applying manifests is really what kubernetes is all about, and the CKAD will depend on this heavily. This will require the user to create a manifest from scratch, or edit an existing yaml. This means that the app should start Vim for the user, displaying the prompt in the vim session with a created file, and then when the user quits Vim, that file should be graded for correctness. The user should not be expected run Vim in an actual CLI, as this will confuse the app and the user. \
\
\
Our Subject Matter Categories will be subordinate to Question Type - that is, every single question type could have a question about ANY one of these subjects: \
- Linux Syntax(Commands from Bash, Vim, Kubectl, Docker, Helm)  \
- Core workloads (Pods, ReplicaSets, Deployments; rollouts/rollbacks)\
- Pod design patterns (initContainers, sidecars, lifecycle hooks)\
- Commands, args, and env (ENTRYPOINT/CMD overrides, env/envFrom)\
- App configuration (ConfigMaps, Secrets, projected & downwardAPI volumes)\
- Probes & health (liveness, readiness, startup; graceful shutdown)\
- Resource management (requests/limits, QoS classes, HPA basics)\
- Jobs & CronJobs (completions, parallelism, backoff, schedules)\
- Services (ClusterIP/NodePort/LoadBalancer, selectors, headless)\
- Ingress/Egress & HTTP routing (basic rules, paths, service backends)\
- Networking utilities (DNS in-cluster, port-forward, exec, curl)\
- Persistence (PVCs, using existing StorageClasses, common volume types)\
- Observability & troubleshooting (logs, describe/events, kubectl debug/ephemeral containers)\
- Metadata Labels, annotations & selectors (label ops, field selectors, jsonpath)\
- Imperative vs declarative (\'97dry-run, create/apply/edit/replace/patch)\
- Container Image & registry use (imagePullPolicy, imagePullSecrets, private registries)\
- Security basics (securityContext, runAsUser/fsGroup, capabilities, readOnlyRootFilesystem)\
- ServiceAccounts in apps (mounting SA, minimal RBAC needed for app access)\
- Scheduling hints (nodeSelector, affinity/anti-affinity, tolerations)\
- Namespaces & contexts (scoping resources, default namespace, context switching)\
- API discovery & docs (kubectl explain, api-resources, api-versions)\
\
You can simplify the categories when actually using the schema (the examples in the parentheticals just help provide context for the specific types) - a short name is fine, ie \'91linux-command\'92 \'91core-workload\'92 \'91routing\'92 \'91api\'92 \'91app-config\'92 \'91pod-design\'92 et cetera for writing to the yaml and to the sqlite db. Each one of the \'91drill\'92 sections should open to something looking like this, using either the short name from our schema classification, or the full description for ease of navigation: \
\
   \uc0\u9675  Linux Syntax(Commands from Vim, Kubectl, Docker ,Helm )  \
   \uc0\u9675  Core workloads (Pods, ReplicaSets, Deployments; rollouts/rollbacks)\
   \uc0\u9675  Pod design patterns (initContainers, sidecars, lifecycle hooks)\
   \uc0\u9675  Commands, args, and env (ENTRYPOINT/CMD overrides, env/envFrom)\
   \uc0\u9675  App configuration (ConfigMaps, Secrets, projected & downwardAPI volumes)\
   \uc0\u9675  Probes & health (liveness, readiness, startup; graceful shutdown)\
   \uc0\u9675  Resource management (requests/limits, QoS classes, HPA basics)\
   \uc0\u9675  Jobs & CronJobs (completions, parallelism, backoff, schedules)\
   \uc0\u9675  Services (ClusterIP/NodePort/LoadBalancer, selectors, headless)\
   \uc0\u9675  Ingress & HTTP routing (basic rules, paths, service backends)\
   \uc0\u9675  Networking utilities (DNS in-cluster, port-forward, exec, curl)\
   \uc0\u9675  Persistence (PVCs, using existing StorageClasses, common volume types)\
   \uc0\u9675  Observability & troubleshooting (logs, describe/events, kubectl debug/ephemeral containers)\
   \uc0\u9675  Labels, annotations & selectors (label ops, field selectors, jsonpath)\
   \uc0\u9675  Imperative vs declarative (\'97dry-run, create/apply/edit/replace/patch)\
   \uc0\u9675  Image & registry use (imagePullPolicy, imagePullSecrets, private registries)\
   \uc0\u9675  Security basics (securityContext, runAsUser/fsGroup, capabilities, readOnlyRootFilesystem)\
   \uc0\u9675  ServiceAccounts in apps (mounting SA, minimal RBAC needed for app access)\
   \uc0\u9675  Scheduling hints (nodeSelector, affinity/anti-affinity, tolerations)\
   \uc0\u9675  Namespaces & contexts (scoping resources, default namespace, context switching)\
   \uc0\u9675  API discovery & docs (kubectl explain, api-resources, api-versions) \
\
\
It must be easy to add questions, either with a schema that you make very explicit and straightforward to implement, or via AI parsing and reformatting. Never delete questions. If they are problematic, add them to a /triage somewhere for later review. The user should have the option to triage questions in the question menu. Do not confuse this with review. Review should be handled entirely by the app. The user will not have the ability to flag or unflag missed questions; that status can only be changed by answering questions. The user should only be able \'91triage\'92 questions that may be vexing for reasons that may be beyond the fault of the user.  \
\
Here is what the question menu should look like: \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\
\uc0\u9675  Answer Question\
\uc0\u9675  Visit Source \
\uc0\u9675  Next Question\
\uc0\u9675  Previous Question\
\uc0\u9675  Triage\
\uc0\u9675  Back (returns to previous menu)\
\
\'91Tool Scripts\'92 will be orchestrated by the script kubelingo_tools.py - edit as needed to handle the six others. Here is what the menu should look like:\
\uc0\u9675  bug_ticket.py\
\uc0\u9675  consolidator.py\
\uc0\u9675  generator.py\
\uc0\u9675  question_manager.py\
\uc0\u9675  sqlite_manager.py\
\uc0\u9675  yaml_manager.py\
\
Repurpose these as much as you need to make the rest of the app work. We should have what we need to help manage other aspects of the app. Feel free to totally delete them and start over if they are spaghetti/confusing. \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
Here are some important rules to remember: \
- It must be easy to add new questions. Provide me a schema and I will format, but also be prepared to format for me with AI. \
- AI feedback happens on every single answer. Attempt to explain the necessary answer, \
or simply the subject matter in question for simpler terminology-based questions. \
- Every question that study mode creates, force it to adhere to the schema, and then store it. Update the metadata table in sqlite after every generation. \
- Every question that the user gets wrong, flag it for review. If they get it right, either in review or if it comes up when running through quiz types, remove it from the flagged list. \
- All of this must be coordinated from a single CLI app.\
- We currently do not have any integration with live clusters. The command syntax should be evaluated with a dry-run, as will the manifests. We do have plans for integration with various sandbox environments, clusters, and other learning modules - but do not let them get in the way of the core architecture we have described here.  \
}