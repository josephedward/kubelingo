[
  {
    "id": "ckad_questions::0",
    "prompt": "In namespace limit create a Pod named resource-checker using image httpd:alpine with container name my-container; requests: cpu=30m, memory=30Mi; limits: cpu=300m, memory=30Mi.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: resource-checker\n  namespace: limit\nspec:\n  containers:\n  - name: my-container\n    image: httpd:alpine\n    resources:\n      requests:\n        cpu: 30m\n        memory: 30Mi\n      limits:\n        cpu: 300m\n        memory: 30Mi",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "answer": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: resource-checker\n  namespace: limit\nspec:\n  containers:\n  - name: my-container\n    image: httpd:alpine\n    resources:\n      requests:\n        cpu: 30m\n        memory: 30Mi\n      limits:\n        cpu: 300m\n        memory: 30Mi"
    }
  },
  {
    "id": "ckad_questions::1",
    "prompt": "Create a ConfigMap named trauerweide with data tree=trauerweide.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: trauerweide\ndata:\n  tree: trauerweide",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "answer": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: trauerweide\ndata:\n  tree: trauerweide"
    }
  },
  {
    "id": "ckad_questions::2",
    "prompt": "Create a Pod named pod1 using image nginx:alpine with env var TREE1 from ConfigMap trauerweide:key=tree and mount all keys of ConfigMap birke under /etc/birke.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: pod1\nspec:\n  containers:\n  - name: nginx\n    image: nginx:alpine\n    env:\n    - name: TREE1\n      valueFrom:\n        configMapKeyRef:\n          name: trauerweide\n          key: tree\n    volumeMounts:\n    - name: birke-volume\n      mountPath: /etc/birke\n  volumes:\n  - name: birke-volume\n    configMap:\n      name: birke",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "answer": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: pod1\nspec:\n  containers:\n  - name: nginx\n    image: nginx:alpine\n    env:\n    - name: TREE1\n      valueFrom:\n        configMapKeyRef:\n          name: trauerweide\n          key: tree\n    volumeMounts:\n    - name: birke-volume\n      mountPath: /etc/birke\n  volumes:\n  - name: birke-volume\n    configMap:\n      name: birke"
    }
  },
  {
    "id": "ckad_questions::3",
    "prompt": "Create a Deployment named space-alien-welcome-message-generator using image httpd:alpine with 1 replica and readinessProbe running stat /tmp/ready with initialDelaySeconds=10 and periodSeconds=5.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: space-alien-welcome-message-generator\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: space-alien-welcome-message-generator\n  template:\n    metadata:\n      labels:\n        app: space-alien-welcome-message-generator\n    spec:\n      containers:\n      - name: httpd\n        image: httpd:alpine\n        readinessProbe:\n          exec:\n            command:\n            - stat\n            - /tmp/ready\n          initialDelaySeconds: 10\n          periodSeconds: 5",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "answer": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: space-alien-welcome-message-generator\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: space-alien-welcome-message-generator\n  template:\n    metadata:\n      labels:\n        app: space-alien-welcome-message-generator\n    spec:\n      containers:\n      - name: httpd\n        image: httpd:alpine\n        readinessProbe:\n          exec:\n            command:\n            - stat\n            - /tmp/ready\n          initialDelaySeconds: 10\n          periodSeconds: 5"
    }
  },
  {
    "id": "vim_quiz_data::0",
    "prompt": "Enter insert mode at cursor",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "i",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": "i",
      "type": "command"
    }
  },
  {
    "id": "vim_quiz_data::1",
    "prompt": "Append text after cursor",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "a",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": "a",
      "type": "command"
    }
  },
  {
    "id": "vim_quiz_data::2",
    "prompt": "Open a new line below the current line",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "o",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": "o",
      "type": "command"
    }
  },
  {
    "id": "vim_quiz_data::3",
    "prompt": "Save file and quit",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":wq",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": ":wq",
      "type": "command"
    }
  },
  {
    "id": "vim_quiz_data::4",
    "prompt": "Exit without saving changes",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":q!",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": ":q!",
      "type": "command"
    }
  },
  {
    "id": "vim_quiz_data::5",
    "prompt": "Save file without exiting",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "w",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": "w",
      "type": "command"
    }
  },
  {
    "id": "vim_quiz_data::6",
    "prompt": "Delete current line",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "dd",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": "dd",
      "type": "command"
    }
  },
  {
    "id": "vim_quiz_data::7",
    "prompt": "Copy current line (yank)",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "yy",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": "yy",
      "type": "command"
    }
  },
  {
    "id": "vim_quiz_data::8",
    "prompt": "Paste after cursor",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "p",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": "p",
      "type": "command"
    }
  },
  {
    "id": "vim_quiz_data::9",
    "prompt": "Undo last change",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "u",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": "u",
      "type": "command"
    }
  },
  {
    "id": "master_quiz_with_explanations::190",
    "prompt": "Search forward for 'pattern'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "/pattern",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Initiates a forward search for `pattern` in the current buffer; press Enter to jump.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "/pattern",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "vim_quiz_data::11",
    "prompt": "Find next search occurrence",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "n",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": "n",
      "type": "command"
    }
  },
  {
    "id": "vim_quiz_data::12",
    "prompt": "Go to top of file",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "gg",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": "gg",
      "type": "command"
    }
  },
  {
    "id": "vim_quiz_data::13",
    "prompt": "Go to end of file",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "G",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": "G",
      "type": "command"
    }
  },
  {
    "id": "vim_quiz_data::14",
    "prompt": "Go to line 10",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":10",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Vim Commands",
      "response": ":10",
      "type": "command"
    }
  },
  {
    "id": "master_quiz_with_explanations::0",
    "prompt": "A 'webapp' deployment is defined in the file. Add a new NodePort service named 'webapp-svc' that exposes the deployment on port 80. The service should target port 8080 on the pods.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {
      "service.yaml": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: webapp\n  labels:\n    app: webapp\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: webapp\n  template:\n    metadata:\n      labels:\n        app: webapp\n    spec:\n      containers:\n      - name: webapp\n        image: httpd\n        ports:\n        - containerPort: 8080\n---\n# Add your Service definition below"
    },
    "validation_steps": [
      {
        "cmd": "#!/bin/bash\nset -e\nkubectl apply -f service.yaml\nkubectl wait --for=condition=available deployment/webapp --timeout=60s > /dev/null\n# Check service exists and is NodePort\nTYPE=$(kubectl get svc webapp-svc -o jsonpath='{.spec.type}')\nif [ \"$TYPE\" != \"NodePort\" ]; then\n  echo \"Error: Service 'webapp-svc' is type '$TYPE', expected 'NodePort'\"\n  exit 1\nfi\n# Check service port and targetPort\nPORT=$(kubectl get svc webapp-svc -o jsonpath='{.spec.ports[0].port}')\nTARGET_PORT=$(kubectl get svc webapp-svc -o jsonpath='{.spec.ports[0].targetPort}')\nif [ \"$PORT\" != \"80\" ]; then\n  echo \"Error: Service port is '$PORT', expected '80'\"\n  exit 1\nfi\nif [ \"$TARGET_PORT\" != \"8080\" ]; then\n  echo \"Error: Service targetPort is '$TARGET_PORT', expected '8080'\"\n  exit 1\nfi\necho \"Service 'webapp-svc' correctly configured as a NodePort.\"",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "You need to add a second resource definition for the Service, setting `spec.type` to `NodePort`, `spec.ports[0].port` to 80, `spec.ports[0].targetPort` to 8080, and `spec.selector` to match the deployment's labels (`app: webapp`).",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Live Kubernetes Questions",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::1",
    "prompt": "Add kubectl autocompletion to ~/.bashrc",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "echo \"source <(kubectl completion bash)\" >> ~/.bashrc",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Appends the completion command to your startup file so every new shell session loads `kubectl` tab-completion automatically.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "echo \"source <(kubectl completion bash)\" >> ~/.bashrc",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::2",
    "prompt": "After creating a pod in the Kubernetes cluster with the image nginx, naming the pod nginx, and exposing it to receive traffic on port 80, change the pod's image to nginx:1.24.0. Observe that the container will be restarted as soon as the image gets pulled.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Kubernetes automatically restarts a container within a pod when its image is updated to ensure the pod runs the latest version specified.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::3",
    "prompt": "After creating a pod in the Kubernetes cluster with the image nginx, naming the pod nginx, and exposing it to receive traffic on port 80, then changing the pod's image to nginx:1.24.0 and observing that the container restarts as soon as the image is pulled, get the nginx pod's IP and use a temporary busybox image to wget its root directory ('/').",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "To retrieve the nginx pod's IP and access its root directory using a temporary busybox container, you would first use `kubectl get pods -o wide` to find the pod's IP, then `kubectl run busybox --rm -it --image=busybox -- wget -O- <nginx-pod-IP>` to execute a wget command from within the busybox container, demonstrating pod-to-pod communication within the Kubernetes cluster.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::4",
    "prompt": "Annotate deployment frontend with description=test",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl annotate deployment frontend description=test",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Adds or updates the annotation `description=test` on `frontend`, useful for non-selective metadata.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl annotate deployment frontend description=test",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::6",
    "prompt": "Apply deployment.yaml without sending to server (dry run)",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl apply -f deployment.yaml --dry-run=client",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Validates and prints the changes locally, ensuring your manifest is correct before touching live resources.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl apply -f deployment.yaml --dry-run=client",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::7",
    "prompt": "Apply the configuration in deployment.yaml",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl apply -f deployment.yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Applies changes from `deployment.yaml` declaratively, creating or patching resources to match the file’s spec.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl apply -f deployment.yaml",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::8",
    "prompt": "Auto-scale deployment frontend to minimum 2 and maximum 5 pods at 80% CPU",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl autoscale deployment frontend --min=2 --max=5 --cpu-percent=80",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Creates an HPA targeting `frontend`, automatically adjusting replicas between 2 and 5 to maintain ~80% CPU utilization.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl autoscale deployment frontend --min=2 --max=5 --cpu-percent=80",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::9",
    "prompt": "Check if you can create pods",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl auth can-i create pods",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Tests your current user’s RBAC permissions for the `create` verb on Pod resources in the active namespace.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl auth can-i create pods",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::10",
    "prompt": "Check the kubectl client and server versions",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl version",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Displays both client and API server versions, helping you verify compatibility and diagnose version-related issues.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl version",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::11",
    "prompt": "Check the rollout status of a deployment named 'frontend'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout status deployment/frontend",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Displays live progress of the `frontend` Deployment’s rollout, reporting when all updated Pods are available or if any failures occur.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl rollout status deployment/frontend",
      "category": "Deployment Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::12",
    "prompt": "Continuously watch pods",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get pods -w",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Keeps the `kubectl get pods` table live, updating your terminal as Pods start, stop, or change status.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get pods -w",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::14",
    "prompt": "Copy file /tmp/data from pod busybox to current directory",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl cp busybox:/tmp/data ./",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Transfers `/tmp/data` from the `busybox` Pod into your local cwd, enabling retrieval of logs or test artifacts.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl cp busybox:/tmp/data ./",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::15",
    "prompt": "Create a ConfigMap from all files in the '/configs' directory",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create cm app-settings --from-file=/configs",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Iterates over every file under `/configs`, creating corresponding keys in `app-settings`, great for grouping multiple configs.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create cm app-settings --from-file=/configs",
      "category": "ConfigMap Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::16",
    "prompt": "Create a ConfigMap from all files in the 'configs' directory",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {
      "configs/conf1": "val1",
      "configs/conf2": "val2"
    },
    "validation_steps": [
      {
        "cmd": "kubectl get cm app-settings",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The correct command to create a ConfigMap from all files in the 'configs' directory is `kubectl create configmap <map-name> --from-file=configs/`, not `kubectl get cm app-settings` which retrieves information about an existing ConfigMap named app-settings.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "ConfigMap Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::17",
    "prompt": "Create a ConfigMap from an env file",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create cm env-config --from-env-file=config.env",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Parses `config.env` (KEY=VALUE per line) into `env-config`, letting containers import it via `envFrom` without manual literal listing.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create cm env-config --from-env-file=config.env",
      "category": "ConfigMap Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::18",
    "prompt": "Create a ConfigMap named 'app-config' with data: database_url=mysql://localhost:3306/app",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [],
    "explanation": "ConfigMap with key-value data for application configuration",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "question_type": "yaml_edit",
      "starting_yaml": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: # TODO: Add name\ndata:\n  # TODO: Add data fields",
      "correct_yaml": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  database_url: mysql://localhost:3306/app",
      "category": "YAML Editing - ConfigMaps",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/yaml_edit_questions.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::19",
    "prompt": "Create a ConfigMap named 'app-config' with key-value pairs: APP_COLOR=blue and APP_MODE=prod",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create cm app-config --from-literal=APP_COLOR=blue --from-literal=APP_MODE=prod",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Builds a ConfigMap `app-config` injecting literals for `APP_COLOR` and `APP_MODE`, which Pods can consume as environment variables or files.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create cm app-config --from-literal=APP_COLOR=blue --from-literal=APP_MODE=prod",
      "category": "ConfigMap Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::20",
    "prompt": "Create a ConfigMap named 'game-config' from a configuration file located at '/configs/game.properties'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create cm game-config --from-file=/configs/game.properties",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Loads the contents of `game.properties` into `game-config`, mapping the filename to a key so containers can mount it as a file.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create cm game-config --from-file=/configs/game.properties",
      "category": "ConfigMap Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::21",
    "prompt": "Create a ConfigMap named 'game-config' from a configuration file located at 'game.properties'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {
      "game.properties": "level=1\nworld=dungeon\n"
    },
    "validation_steps": [
      {
        "cmd": "kubectl get cm game-config",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The correct command to create a ConfigMap named 'game-config' from a file is `kubectl create configmap game-config --from-file=game.properties`, not `kubectl get cm game-config` which only retrieves information about an existing ConfigMap.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "ConfigMap Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::22",
    "prompt": "Create a ConfigMap named 'multi-config' with key-value pairs DB_URL=mysql://db, API_KEY=123456, and DEBUG=true from the command line",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create cm multi-config --from-literal=DB_URL=mysql://db --from-literal=API_KEY=123456 --from-literal=DEBUG=true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Bundles three literals into `multi-config`, showcasing how to supply multiple discrete settings in a single invocation.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create cm multi-config --from-literal=DB_URL=mysql://db --from-literal=API_KEY=123456 --from-literal=DEBUG=true",
      "category": "ConfigMap Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::23",
    "prompt": "Create a ConfigMap named app-config from file config.yaml",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create configmap app-config --from-file=config.yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Loads `config.yaml` into key `config.yaml` in the ConfigMap, making it mountable or env-injectable for Pods.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create configmap app-config --from-file=config.yaml",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::25",
    "prompt": "Create a Deployment named 'frontend' with 3 replicas of nginx:1.21",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [],
    "explanation": "Deployment with replica count and proper label selectors",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "question_type": "yaml_edit",
      "starting_yaml": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: # TODO: Add name\nspec:\n  replicas: # TODO: Set replicas\n  selector:\n    matchLabels:\n      app: frontend\n  template:\n    metadata:\n      labels:\n        app: frontend\n    spec:\n      containers:\n      - name: nginx\n        image: # TODO: Set image",
      "correct_yaml": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: frontend\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: frontend\n  template:\n    metadata:\n      labels:\n        app: frontend\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21",
      "category": "YAML Editing - Deployments",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/yaml_edit_questions.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::27",
    "prompt": "Create a Pod named 'web-server' using nginx:1.20 image, expose port 80",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [],
    "explanation": "Basic pod with specific name, image, and port configuration",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "question_type": "yaml_edit",
      "starting_yaml": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: # TODO: Add name\nspec:\n  containers:\n  - name: # TODO: Add container name\n    image: # TODO: Add image\n    ports:\n    - containerPort: # TODO: Add port",
      "correct_yaml": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: web-server\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.20\n    ports:\n    - containerPort: 80",
      "category": "YAML Editing - Pods",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/yaml_edit_questions.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::28",
    "prompt": "Create a Pod named `config-pod` using the `busybox` image that mounts a ConfigMap named `app-config` as a volume at `/etc/config`",
    "type": "command",
    "pre_shell_cmds": [
      "kubectl create configmap app-config --from-literal=key=value"
    ],
    "initial_files": {
      "pod.yaml": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: config-pod\nspec:\n  containers:\n  - name: busybox\n    image: busybox\n    command: ['sleep', '3600']\n"
    },
    "validation_steps": [
      {
        "cmd": "kubectl apply -f pod.yaml && kubectl get pod config-pod -o jsonpath='{.spec.volumes[0].configMap.name}' | grep 'app-config' && kubectl get pod config-pod -o jsonpath='{.spec.containers[0].volumeMounts[0].mountPath}' | grep '/etc/config'",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The command sequence applies a configuration from a YAML file to create a Pod, then verifies that the Pod mounts the specified ConfigMap `app-config` at the correct path `/etc/config` by extracting and checking these details from the Pod's specification.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Pod Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::30",
    "prompt": "Create a Pod with environment variables: DB_HOST=localhost, DB_PORT=5432",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [],
    "explanation": "Pod with environment variables defined in container spec",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "question_type": "yaml_edit",
      "starting_yaml": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\nspec:\n  containers:\n  - name: app\n    image: nginx\n    env:\n    # TODO: Add environment variables",
      "correct_yaml": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\nspec:\n  containers:\n  - name: app\n    image: nginx\n    env:\n    - name: DB_HOST\n      value: localhost\n    - name: DB_PORT\n      value: \"5432\"",
      "category": "YAML Editing - Pods",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/yaml_edit_questions.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::31",
    "prompt": "Create a Secret from a .env file",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create secret generic my-secrets --from-env-file=.env",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Converts each `KEY=VALUE` line in `.env` into data entries in `my-secrets`, streamlining multi-value secret ingestion.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create secret generic my-secrets --from-env-file=.env",
      "category": "Secret Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::32",
    "prompt": "Create a Secret named 'db-creds' with username=admin and password=password123",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create secret generic db-creds --from-literal=username=admin --from-literal=password=password123",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Encodes `username` and `password` into a base64 Secret `db-creds`, which Pods can consume via `secretKeyRef` to keep credentials out of plaintext manifests.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create secret generic db-creds --from-literal=username=admin --from-literal=password=password123",
      "category": "Secret Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::33",
    "prompt": "Create a Secret named 'tls-cert' from a certificate file",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create secret generic tls-cert --from-file=/path/to/cert.pem",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Imports the raw bytes of `cert.pem` into `tls-cert`, ideal when you need to inject TLS assets into containers without baking them into images.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create secret generic tls-cert --from-file=/path/to/cert.pem",
      "category": "Secret Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::34",
    "prompt": "Create a Service Account named 'deployment-sa'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create sa deployment-sa",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Provisions a ServiceAccount `deployment-sa`, which Pods can reference under `spec.serviceAccountName` to assume its RBAC permissions.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create sa deployment-sa",
      "category": "Service Account Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::35",
    "prompt": "Create a ServiceAccount named default-sa",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create serviceaccount default-sa",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Adds a custom ServiceAccount `default-sa`; Pods specifying it will inherit its token and RBAC scopes.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create serviceaccount default-sa",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::36",
    "prompt": "Create a TLS Secret type from certificate and key files",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create secret tls my-tls --cert=path/to/cert.crt --key=path/to/key.key",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Bundles a cert/key pair into a `tls` Secret, which Ingress controllers and web servers natively understand for TLS termination.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create secret tls my-tls --cert=path/to/cert.crt --key=path/to/key.key",
      "category": "Secret Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::37",
    "prompt": "Create a busybox pod that echoes 'hello world' and then exits, ensuring it is separate from an initially created nginx pod that was later updated to use the nginx:1.24.0 image and exposed to receive traffic on port 80. Additionally, configure the busybox pod to be deleted automatically once it has completed its task.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The busybox pod can be created with a Job or a CronJob resource in Kubernetes, which supports running a command (echo 'hello world') and then exiting, with the Job's `ttlSecondsAfterFinished` feature enabling automatic deletion after completion, ensuring it operates independently of any nginx pod configurations or updates.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::38",
    "prompt": "Create a busybox pod that echoes 'hello world' and then exits, ensuring it is separate from the nginx pod initially created with the nginx image and later updated to use the nginx:1.24.0 image, which is exposed to receive traffic on port 80.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "To create a busybox pod that echoes 'hello world' and then exits, while ensuring it does not interfere with an existing nginx pod, you would use a pod definition that specifies the busybox image and the command to echo 'hello world', without altering the nginx pod's configuration or service definitions that expose it on port 80.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::39",
    "prompt": "Create a busybox pod using YAML that runs the command \"env\" and is placed in the 'mynamespace' namespace, similar to the nginx pod created in a previous task. Run the pod and see the output.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "To create a busybox pod that runs the \"env\" command in the 'mynamespace' namespace, you need to define a pod in a YAML file specifying the container image as busybox, the command to run, and the namespace, then apply this YAML file with kubectl to create the pod and use `kubectl logs` to see the output.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::40",
    "prompt": "Create a busybox pod using the kubectl command that runs the command \"env\". Ensure the pod is named 'busybox' and it is created in the same namespace ('mynamespace') as the nginx pod specified in the previous task. Run the pod and see the output.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The correct command to achieve this would involve using `kubectl run busybox --namespace=mynamespace --image=busybox --restart=Never -- env`, which creates a pod named 'busybox' in the specified namespace 'mynamespace', using the busybox image to run the 'env' command once before exiting, showcasing how to execute a specific command within a pod at creation.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::41",
    "prompt": "Create a deployment named frontend using image nginx:1.14",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create deployment frontend --image=nginx:1.14",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Sets up `frontend` Deployment running `nginx:1.14`, managing Pods declaratively with rolling updates.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create deployment frontend --image=nginx:1.14",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::42",
    "prompt": "Create a deployment named webapp with image nginx:1.17 and 3 replicas",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create deployment webapp --image=nginx:1.17 --replicas=3",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Creates a Deployment object `webapp` running `nginx:1.17` across 3 Pods, ensuring declarative rolling updates, self-healing, and scaling capabilities under the hood.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create deployment webapp --image=nginx:1.17 --replicas=3",
      "category": "Deployment Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::43",
    "prompt": "Create a deployment with a record of the change-cause for future reference",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create deployment nginx --image=nginx --record",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Adds an annotation capturing the command that triggered this Deployment, letting you later inspect `kubectl rollout history` to trace change causes.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create deployment nginx --image=nginx --record",
      "category": "Deployment Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::44",
    "prompt": "Create a docker-registry type Secret for private registry authentication",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create secret docker-registry regcred --docker-server=REGISTRY_SERVER --docker-username=USERNAME --docker-password=PASSWORD --docker-email=EMAIL",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Generates a `.dockerconfigjson`–style Secret that Kubernetes uses to pull from private registries, embedding credentials securely.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create secret docker-registry regcred --docker-server=REGISTRY_SERVER --docker-username=USERNAME --docker-password=PASSWORD --docker-email=EMAIL",
      "category": "Secret Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::45",
    "prompt": "Create a generic secret named db-secret with literal username and password",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create secret generic db-secret --from-literal=username=admin --from-literal=password=secret",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Builds `db-secret` with two data entries for secure credential distribution to Pods.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create secret generic db-secret --from-literal=username=admin --from-literal=password=secret",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::46",
    "prompt": "Create a namespace called 'mynamespace' and a pod with image nginx called nginx on this namespace",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get ns mynamespace",
        "matcher": {
          "exit_code": 0
        }
      },
      {
        "cmd": "kubectl get pod nginx -n mynamespace",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The provided answer is incorrect; to create a namespace called 'mynamespace' and a pod named nginx with the nginx image in this namespace, you would first use `kubectl create namespace mynamespace` to create the namespace, followed by `kubectl run nginx --image=nginx --namespace=mynamespace` to create the pod within that namespace.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::47",
    "prompt": "Create a namespace named dev",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create namespace dev",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Bootstraps a new `dev` namespace for isolating development workloads from others.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create namespace dev",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::48",
    "prompt": "Create a new namespace called 'development'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create namespace development",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Provision a logical scope `development` in the cluster, isolating resources and RBAC policies under its own boundary.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create namespace development",
      "category": "Namespace Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::49",
    "prompt": "Create a new namespace called 'testing' and output its YAML definition",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create ns testing --dry-run=client -o yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Renders the `testing` Namespace manifest without creating it, giving you a versioned YAML stub for review or customization.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create ns testing --dry-run=client -o yaml",
      "category": "Namespace Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::50",
    "prompt": "Create a pod in the 'development' namespace",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx -n development",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Launches a Pod named `nginx` within `development`, isolating it from other namespaces and inheriting the namespace’s resource quotas and policies.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run nginx --image=nginx -n development",
      "category": "Namespace Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::51",
    "prompt": "Create a pod in the Kubernetes cluster with the image nginx, name the pod nginx, and expose it to receive traffic on port 80.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The command `kubectl run nginx --image=nginx --port=80` creates a pod named nginx using the nginx image and exposes it internally on port 80 to receive traffic.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::52",
    "prompt": "Create a pod named busybox that runs the command 'sleep 3600'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run busybox --image=busybox -- sleep 3600",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Launches a Pod named `busybox` that executes `sleep 3600` as its entrypoint, using the minimal BusyBox image. Useful for ephemeral debug containers that remain alive long enough for exec- or log-based inspection.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run busybox --image=busybox -- sleep 3600",
      "category": "Pod Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::53",
    "prompt": "Create a pod named nginx using the nginx image and expose port 80",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx --port=80",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Invokes `kubectl run` to create a standalone Pod called `nginx`, pulling the official `nginx` image and annotating its container spec with port 80, so Services or `kubectl port-forward` can route traffic. Ideal for quick dev-mode tests before wrapping in a Deployment for production.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run nginx --image=nginx --port=80",
      "category": "Pod Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::54",
    "prompt": "Create a pod named nginx using the nginx image and expose port 80. You can use 'kubectl run' or create a YAML file.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "#!/bin/bash\nset -e\nPOD_NAME=$(kubectl get pod nginx -o jsonpath='{.metadata.name}' 2>/dev/null)\nif [ \"$POD_NAME\" != \"nginx\" ]; then\n  echo \"Error: Pod 'nginx' not found.\"\n  exit 1\nfi\nIMAGE=$(kubectl get pod nginx -o jsonpath='{.spec.containers[0].image}')\nif [ \"$IMAGE\" != \"nginx\" ]; then\n  echo \"Error: Image is '$IMAGE', expected 'nginx'.\"\n  exit 1\nfi\nPORT=$(kubectl get pod nginx -o jsonpath='{.spec.containers[0].ports[0].containerPort}')\nif [ \"$PORT\" != \"80\" ]; then\n  echo \"Error: Port is '$PORT', expected '80'.\"\n  exit 1\nfi\necho \"Pod 'nginx' with image 'nginx' and port 80 found.\"",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "You can solve this with 'kubectl run nginx --image=nginx --port=80' or by creating a Pod manifest with the specified image and containerPort.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Pod Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::55",
    "prompt": "Create a pod named nginx using the nginx image and set labels app=web and tier=frontend",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx --labels=\"app=web,tier=frontend\"",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Tags the new `nginx` Pod with `app=web` and `tier=frontend` labels, enabling Services, ReplicaSets, and `kubectl get -l` selectors to group and manage it alongside related resources.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run nginx --image=nginx --labels=\"app=web,tier=frontend\"",
      "category": "Pod Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::56",
    "prompt": "Create a pod that mounts a Secret as a volume using the nginx image",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run secret-pod --image=nginx --dry-run=client -o yaml > pod.yaml # add volume.secret",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Creates a Pod manifest; under `spec.volumes` reference `secret.name: my-secrets` and mount into the container to expose files rather than env vars.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run secret-pod --image=nginx --dry-run=client -o yaml > pod.yaml # add volume.secret",
      "category": "Secret Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::57",
    "prompt": "Create a pod that runs curl against an internal service at 10.244.0.4",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run curl1 --image=curlimages/curl -i -t --rm --restart=Never -- curl 10.244.0.4",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Launches a disposable Pod named `curl1` to execute `curl 10.244.0.4` inside the cluster; `--rm` and `--restart=Never` ensure it doesn’t persist, while `-i -t` streams output to your terminal.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run curl1 --image=curlimages/curl -i -t --rm --restart=Never -- curl 10.244.0.4",
      "category": "Pod Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::58",
    "prompt": "Create a pod that runs the latest nginx image and sets an environment variable DB_URL=postgresql://db",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx --env=\"DB_URL=postgresql://db\"",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Spawns an `nginx` Pod with `DB_URL` injected into the container’s environment, letting the process read database connection info at runtime; for sensitive data, prefer mounting Secrets or ConfigMaps instead of literals.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run nginx --image=nginx --env=\"DB_URL=postgresql://db\"",
      "category": "Pod Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::59",
    "prompt": "Create a pod that uses a ConfigMap as environment variables",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run app --image=nginx --dry-run=client -o yaml > pod.yaml # add envFrom with configMapRef",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Generates a Pod spec stub; you then add `envFrom.configMapRef.name: app-config` under the container to import all ConfigMap keys as env vars.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run app --image=nginx --dry-run=client -o yaml > pod.yaml # add envFrom with configMapRef",
      "category": "ConfigMap Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::60",
    "prompt": "Create a pod that uses a Secret value as an environment variable",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run secure-app --image=nginx --dry-run=client -o yaml > pod.yaml # add env.secretKeyRef",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Emits a Pod spec stub; modify `env` to reference `secretKeyRef.name: db-creds, key: password` so the container sees the secret at runtime without plaintext.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run secure-app --image=nginx --dry-run=client -o yaml > pod.yaml # add env.secretKeyRef",
      "category": "Secret Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::61",
    "prompt": "Create a pod with resource requests of 100m CPU and 256Mi memory",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx --dry-run=client -o yaml > pod.yaml # then add resource requests",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Dumps a Pod spec to `pod.yaml`, which you then enrich under `resources.requests` with `cpu: \"100m\"` and `memory: \"256Mi\"` so the scheduler reserves minimal compute and memory for the container.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run nginx --image=nginx --dry-run=client -o yaml > pod.yaml # then add resource requests",
      "category": "Pod Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::62",
    "prompt": "Create a pod with the image nginx called nginx in a namespace called 'mynamespace' using YAML.",
    "type": "command",
    "pre_shell_cmds": [
      "kubectl create ns mynamespace"
    ],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "test -f pod.yaml",
        "matcher": {
          "exit_code": 0
        }
      },
      {
        "cmd": "kubectl get pod nginx -n mynamespace",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The command \"test -f pod.yaml\" checks if a file named pod.yaml exists but does not create a pod; to create a pod, one would need to use `kubectl apply -f pod.yaml` with the appropriate YAML configuration for the pod.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::63",
    "prompt": "Create a resource quota for a namespace limiting it to 10 pods",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create quota ns-quota --hard=pods=10 -n development",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Establishes a `ResourceQuota` named `ns-quota` in `development`, capping Pod creation at 10 to prevent resource exhaustion.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create quota ns-quota --hard=pods=10 -n development",
      "category": "Namespace Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::64",
    "prompt": "Create an alias 'k' for 'kubectl'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "alias k=kubectl",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Defines a shell alias `k` so you can type `k get pods` instead of `kubectl get pods`, saving keystrokes on every invocation.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "alias k=kubectl",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::65",
    "prompt": "Create an alias 'kc' for 'kubectl create'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "alias kc='kubectl create'",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Defines a shell alias `kc` so you can type `kc deployment webapp --image=nginx` instead of `kubectl create deployment webapp --image=nginx`, simplifying resource creation.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "alias kc='kubectl create'",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::66",
    "prompt": "Create an alias 'kd' for 'kubectl describe'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "alias kd='kubectl describe'",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Defines a shell alias `kd` so you can type `kd pod nginx` instead of `kubectl describe pod nginx`, streamlining the describe command.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "alias kd='kubectl describe'",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::67",
    "prompt": "Create an alias 'ke' for 'kubectl explain'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "alias ke='kubectl explain'",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Defines a shell alias `ke` so you can type `ke pods` instead of `kubectl explain pods`, making API field lookup quicker.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "alias ke='kubectl explain'",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::68",
    "prompt": "Create an alias 'kgp' for 'kubectl get pods'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "alias kgp='kubectl get pods'",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Defines a shell alias `kgp` so you can list pods with just `kgp`, reducing typing for frequent pod listings.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "alias kgp='kubectl get pods'",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::69",
    "prompt": "Create an alias 'kgs' for 'kubectl get svc'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "alias kgs='kubectl get svc'",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Defines a shell alias `kgs` so you can list services with just `kgs`, making service inspection faster.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "alias kgs='kubectl get svc'",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::70",
    "prompt": "Create an alias 'kr' for 'kubectl run'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "alias kr='kubectl run'",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Defines a shell alias `kr` so you can type `kr nginx --image=nginx` instead of `kubectl run nginx --image=nginx`, speeding up pod creation.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "alias kr='kubectl run'",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::71",
    "prompt": "Create an interactive temporary pod with Ubuntu image to troubleshoot cluster issues",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run my-shell --rm -i --tty --image=ubuntu -- bash",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Starts a one-off `ubuntu` Pod named `my-shell` with an interactive Bash shell; flags `-i --tty` attach your terminal, and `--rm` auto-cleans the Pod on exit—perfect for ad hoc network or volume tests.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run my-shell --rm -i --tty --image=ubuntu -- bash",
      "category": "Pod Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::72",
    "prompt": "Create an nginx pod, separate from the busybox pod that echoes 'hello world' and then exits. Ensure this nginx pod is set with an environment variable 'var1=val1' and verify the existence of this environment variable within the pod.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "To create an nginx pod with a specific environment variable, you would use a pod definition that specifies nginx as the container image and includes the environment variable 'var1=val1' in the container's configuration, then you can verify the environment variable by executing a command inside the running pod, such as `kubectl exec [pod-name] -- printenv var1`, ensuring the pod's configuration and operational environment meet the specified requirements.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::73",
    "prompt": "Create the YAML definition for a new ResourceQuota called 'myrq' in the namespace 'myns', where you previously created a busybox pod that runs the command \"env\". The ResourceQuota should have hard limits of 1 CPU, 1G memory, and allow for a maximum of 2 pods, all without actually creating the ResourceQuota.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The `kubectl create quota myrq --hard=cpu=1,memory=1G,pods=2 --dry-run=client -o yaml -n myns` command generates the YAML definition for a ResourceQuota named 'myrq' with specified limits, using the `--dry-run=client` option to prevent actual creation, and outputs it in YAML format.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::74",
    "prompt": "Create two resources: 1. A ConfigMap named 'app-config' with data 'index.html: <h1>Hello World</h1>'. 2. A Pod named 'web-server' using the 'nginx' image that mounts the ConfigMap as a volume at '/usr/share/nginx/html', replacing the default nginx page.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {
      "resources.yaml": "# Add your ConfigMap and Pod definitions here"
    },
    "validation_steps": [
      {
        "cmd": "#!/bin/bash\nset -e\nkubectl apply -f resources.yaml\n# Check ConfigMap data\nDATA=$(kubectl get cm app-config -o jsonpath='{.data.index\\.html}')\nif ! echo \"$DATA\" | grep -q 'Hello World'; then\n  echo \"Error: ConfigMap 'app-config' does not have the correct data.\"\n  exit 1\nfi\n# Wait for pod to be ready\nkubectl wait --for=condition=Ready pod/web-server --timeout=120s > /dev/null\n# Check that the mounted file contains the correct content\nCONTENT=$(kubectl exec web-server -- curl -s localhost)\nif ! echo \"$CONTENT\" | grep -q 'Hello World'; then\n  echo \"Error: The web server did not return the expected content from the ConfigMap.\"\n  echo \"Received: $CONTENT\"\n  exit 1\nfi\necho \"Pod is serving content from the mounted ConfigMap correctly.\"",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "You need to define a ConfigMap with the specified data. Then, define a Pod that references this ConfigMap in `spec.volumes` and mounts it into the container at the correct path using `spec.containers[0].volumeMounts`.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Live Kubernetes Questions",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::75",
    "prompt": "Decode a base64 encoded Secret value",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "echo -n 'encoded string...' | base64 --decode",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Reverses the encoding, revealing the original plaintext—handy for quick checks of Secret contents on the CLI.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "echo -n 'encoded string...' | base64 --decode",
      "category": "Secret Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::76",
    "prompt": "Delete a namespace called 'testing' and all its resources",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl delete namespace testing",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Removes the entire `testing` namespace object, cascading deletion to every resource contained within.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl delete namespace testing",
      "category": "Namespace Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::77",
    "prompt": "Delete configmap app-config",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl delete configmap app-config",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Removes the `app-config` resource; Pods mounting it will see no files or errors on next restart.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl delete configmap app-config",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::79",
    "prompt": "Delete deployment frontend",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl delete deployment frontend",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Removes the `frontend` Deployment and its managed ReplicaSets and Pods.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl delete deployment frontend",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::80",
    "prompt": "Delete namespace dev",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl delete namespace dev",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Tears down `dev` and all resources within—use carefully to avoid data loss.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl delete namespace dev",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::81",
    "prompt": "Delete pod busybox",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl delete pod busybox",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Immediately removes the `busybox` Pod from the cluster; if managed by a higher-level controller it may be recreated.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl delete pod busybox",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::82",
    "prompt": "Delete secret db-secret",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl delete secret db-secret",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Purges the `db-secret` resource, revoking any Pod’s access to its values.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl delete secret db-secret",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::83",
    "prompt": "Delete service frontend-svc",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl delete service frontend-svc",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Removes the `frontend-svc` Service; client traffic will no longer route to backend Pods.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl delete service frontend-svc",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::84",
    "prompt": "Delete serviceaccount default-sa",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl delete serviceaccount default-sa",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Removes the `default-sa` object, invalidating its token Secret.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl delete serviceaccount default-sa",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::85",
    "prompt": "Delete the current line",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "dd",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Removes the line under the cursor in Vim’s normal mode.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "dd",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::86",
    "prompt": "Describe configmap app-config",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl describe configmap app-config",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Reveals keys, data sizes, and events for `app-config` to help validate expected content.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl describe configmap app-config",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::87",
    "prompt": "Describe deployment frontend",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl describe deployment frontend",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Provides full detail of `frontend`’s spec, ReplicaSets, events, and rollout history.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl describe deployment frontend",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::88",
    "prompt": "Describe namespace dev",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl describe namespace dev",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Reveals details about `dev`’s annotations, labels, and any events tied to its lifecycle.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl describe namespace dev",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::89",
    "prompt": "Describe node worker-node-1",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl describe node worker-node-1",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Gives full node details—capacity, allocatable resources, taints, conditions, and running Pods—for cluster operations.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl describe node worker-node-1",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::90",
    "prompt": "Describe pod busybox",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl describe pod busybox",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Shows the full YAML spec, conditions, events, and container statuses for the `busybox` Pod.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl describe pod busybox",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::91",
    "prompt": "Describe pod busybox for troubleshooting",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl describe pod busybox",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Displays event history, container states, and resource details to pinpoint Pod startup or runtime issues.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl describe pod busybox",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::92",
    "prompt": "Describe secret db-secret",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl describe secret db-secret",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Lists metadata and type of `db-secret`, but does not reveal values (use `-o yaml` to see base64-encoded data).",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl describe secret db-secret",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::93",
    "prompt": "Describe service frontend-svc",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl describe service frontend-svc",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Provides the Service’s selectors, endpoints, port mappings, and any related events.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl describe service frontend-svc",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::94",
    "prompt": "Describe serviceaccount default-sa",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl describe serviceaccount default-sa",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Shows the linked Secret tokens and any associated image pull secrets for `default-sa`.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl describe serviceaccount default-sa",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::95",
    "prompt": "Display cluster info",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl cluster-info",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Shows API server and DNS endpoints for the cluster, confirming connectivity.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl cluster-info",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::96",
    "prompt": "Enable kubectl autocomplete in your shell",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "source <(kubectl completion bash)\ncomplete -F __start_kubectl k",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Loads the kubectl bash completion script and registers it for the `k` alias, providing real-time tab-completion of commands, flags, and resource names.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "source <(kubectl completion bash)\ncomplete -F __start_kubectl k",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::97",
    "prompt": "Enable kubectl autocompletion for bash",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "source <(kubectl completion bash)",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Activates real-time tab-completion for `kubectl` commands and flags in your current shell session, speeding up CLI usage.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "source <(kubectl completion bash)",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::98",
    "prompt": "Encode a string for use in a Secret YAML definition",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "echo -n 'string' | base64",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Pipes `string` through `base64` to produce the encoded representation required in Secret manifests under `data:`.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "echo -n 'string' | base64",
      "category": "Secret Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::99",
    "prompt": "Enter insert mode",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "i",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Switches Vim into insert mode, letting you type text into the file.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "i",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::101",
    "prompt": "Enter replace mode",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "R",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Switches into replace mode where typed characters overwrite existing text.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "R",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::102",
    "prompt": "Enter visual block mode",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "<C-v>",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Starts block-wise (column) selection in Vim.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "<C-v>",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::103",
    "prompt": "Enter visual line mode",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "V",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Starts line-wise selection in Vim.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "V",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::104",
    "prompt": "Enter visual mode",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "v",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Starts character-wise selection in Vim.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "v",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::105",
    "prompt": "Execute a shell in pod busybox",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl exec -it busybox -- /bin/sh",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Spawns an interactive `/bin/sh` session into the running `busybox` Pod container for real-time debug commands.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl exec -it busybox -- /bin/sh",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::106",
    "prompt": "Execute a simple shell command on the nginx pod, which was initially created with the nginx image and then updated to use the nginx:1.24.0 image, and is exposed to receive traffic on port 80.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The command demonstrates how to interact with a specific pod by executing commands inside it, showcasing Kubernetes' ability to manage and interact with containerized applications.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::107",
    "prompt": "Exit insert mode",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "<Esc>",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Returns to command mode from insert mode in Vim.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "<Esc>",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::109",
    "prompt": "Explain the fields of pods",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl explain pods",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Provides documentation on the `Pod` object’s schema, walking you through each spec and status field.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl explain pods",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::110",
    "prompt": "Expose deployment frontend on port 80 as a ClusterIP service named frontend-svc",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl expose deployment frontend --port=80 --type=ClusterIP --name=frontend-svc",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Creates a Service `frontend-svc` of type ClusterIP that load-balances traffic to the `frontend` Pods on port 80.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl expose deployment frontend --port=80 --type=ClusterIP --name=frontend-svc",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::111",
    "prompt": "Extract a ConfigMap to YAML format",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get cm app-config -o yaml > config.yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Dumps `app-config`’s full manifest, including data entries, into `config.yaml` for backup or diff-based change tracking.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get cm app-config -o yaml > config.yaml",
      "category": "ConfigMap Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::112",
    "prompt": "Extract the YAML definition of a running pod named 'webapp' in the 'development' namespace",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get pod webapp -n development -o yaml > webapp.yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Retrieves the live Pod object `webapp` from namespace `development` and outputs its complete spec, metadata, and status as YAML into `webapp.yaml`, allowing diff-based debugging against source manifests.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get pod webapp -n development -o yaml > webapp.yaml",
      "category": "Pod Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::114",
    "prompt": "Follow logs of pod busybox",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl logs busybox -f",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Tails `busybox` logs in real time, keeping the stream open until you interrupt (Ctrl+C).",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl logs busybox -f",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::115",
    "prompt": "Generate YAML for deployment 'test' using the nginx image without creating it",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create deployment test --image=nginx --dry-run=client -o yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Locally outputs the `test` Deployment spec as YAML for review, avoiding API server calls.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create deployment test --image=nginx --dry-run=client -o yaml",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::116",
    "prompt": "Generate a YAML definition file for a pod named nginx without creating it",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx --dry-run=client -o yaml > nginx.yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Uses `--dry-run=client` with `-o yaml` to locally render the full Pod manifest for `nginx` without contacting the API server, saving it as `nginx.yaml`. You can then customize or version-control before applying.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run nginx --image=nginx --dry-run=client -o yaml > nginx.yaml",
      "category": "Pod Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::117",
    "prompt": "Generate a YAML file for a deployment with nginx image without creating it",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create deployment nginx --image=nginx --dry-run=client -o yaml > deploy.yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Renders the Deployment spec for `nginx` locally as `deploy.yaml` without persisting it, letting you review or tweak rollout strategy (e.g., `spec.strategy`) before `kubectl apply -f`.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl create deployment nginx --image=nginx --dry-run=client -o yaml > deploy.yaml",
      "category": "Deployment Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::118",
    "prompt": "Get all resources in all namespaces",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get all -A",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Aggregates core resource types across every namespace for a cluster-wide overview.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get all -A",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::119",
    "prompt": "Get information about the nginx pod, which was initially created with the nginx image, named nginx, exposed to receive traffic on port 80, and later had its image updated to nginx:1.24.0, including details about potential issues (e.g., pod hasn't started).",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The command retrieves detailed information and status about the specific nginx pod, including its update history to nginx:1.24.0 and any issues preventing it from starting, which is crucial for troubleshooting and ensuring the pod is configured correctly.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::120",
    "prompt": "Get pod busybox in JSON format",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get pods busybox -o json",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Same as above but in JSON, useful for scripting via `jq` or other tooling.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get pods busybox -o json",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::121",
    "prompt": "Get pod busybox in YAML format",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get pods busybox -o yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Outputs the full Pod object as YAML so you can inspect computed fields, status, and metadata.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get pods busybox -o yaml",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::122",
    "prompt": "Get pods with all labels",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get pods --show-labels",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Shows the full set of labels for each listed Pod in the table output.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get pods --show-labels",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::123",
    "prompt": "Get pods with label app=frontend",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get pods -l app=frontend",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Filters Pods by the `app=frontend` label selector, returning only matching workloads.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get pods -l app=frontend",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::124",
    "prompt": "Get the YAML definition for a new namespace called 'myns' without actually creating the namespace. This follows a previous task where you created a busybox pod that runs the command \"env\" and is placed in the 'mynamespace' namespace using YAML.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The correct command to get the YAML definition for a new namespace called 'myns' without creating it is `kubectl create namespace myns --dry-run=client -o yaml`, which simulates the creation of the namespace and outputs the YAML configuration, aligning with Kubernetes' practice of declarative configuration.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::125",
    "prompt": "Get the logs of the nginx pod, named nginx, which was initially created with the nginx image, then updated to use the nginx:1.24.0 image, and is exposed to receive traffic on port 80.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The command retrieves the operational history of the specified nginx pod, allowing insight into its behavior and performance after the image update and its network exposure settings.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::128",
    "prompt": "Go to line N",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":N",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Jumps directly to line number N in the file.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": ":N",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::130",
    "prompt": "If the nginx pod, named nginx, which was initially created with the nginx image, then updated to use the nginx:1.24.0 image, and is exposed to receive traffic on port 80, crashed and restarted, get logs about the previous instance.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The command `kubectl logs nginx -p` retrieves logs from the previous instance of a container within a pod, useful for debugging issues that caused the container to crash and restart.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::132",
    "prompt": "Jump to matching bracket",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "%",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Toggles between matching `{}`, `[]`, or parentheses, useful in nested code blocks.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "%",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::133",
    "prompt": "Label pod busybox with env=prod",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl label pod busybox env=prod",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Attaches the label `env=prod` to the `busybox` Pod, which can drive Service selectors or monitoring filters.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl label pod busybox env=prod",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::134",
    "prompt": "List ConfigMaps using the short alias",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "k get cm",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Uses `cm` as the short resource name for ConfigMaps with the `k` alias to quickly list ConfigMaps.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "k get cm",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::135",
    "prompt": "List HorizontalPodAutoscalers using the short alias",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "k get hpa",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Uses `hpa` as the short resource name for HorizontalPodAutoscalers with the `k` alias.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "k get hpa",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::136",
    "prompt": "List Ingresses using the short alias",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "k get ing",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Uses `ing` as the short resource name for Ingress resources with the `k` alias.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "k get ing",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::137",
    "prompt": "List NetworkPolicies using the short alias",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "k get netpol",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Uses `netpol` as the short resource name for NetworkPolicy objects with the `k` alias.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "k get netpol",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::138",
    "prompt": "List ServiceAccounts using the short alias",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "k get sa",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Uses `sa` as the short resource name for ServiceAccounts with the `k` alias.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "k get sa",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::139",
    "prompt": "List all ConfigMaps",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get configmaps",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Lists each ConfigMap name and age in the namespace.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get configmaps",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::140",
    "prompt": "List all Service Accounts in the current namespace",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get sa",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Shows every ServiceAccount object in the active namespace, including defaults like `default` and any custom ones you’ve created.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get sa",
      "category": "Service Account Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::141",
    "prompt": "List all ServiceAccounts",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get serviceaccounts",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Lists each ServiceAccount object in the namespace, including the default one created automatically.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get serviceaccounts",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::142",
    "prompt": "List all contexts",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl config get-contexts",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Enumerates each context entry—cluster, user, namespace combos—available in your kubeconfig.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl config get-contexts",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::143",
    "prompt": "List all deployments",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get deployments",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Shows each Deployment’s name, desired vs. current replicas, and availability status.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get deployments",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::144",
    "prompt": "List all events",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get events",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Shows recent cluster events (e.g., scheduling failures, restarts) in chronological order for debugging.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get events",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::145",
    "prompt": "List all namespaces",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get namespaces",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Enumerates every namespace, showing their current status (Active/Terminating) and age.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get namespaces",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::146",
    "prompt": "List all namespaces in the cluster",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get namespaces",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Displays every namespace, their statuses, and age—useful for housekeeping or capacity planning.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get namespaces",
      "category": "Namespace Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::147",
    "prompt": "List all pods",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get pods",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Displays every Pod in the current namespace, their READY status, restarts, and age.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get pods",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::148",
    "prompt": "List all pods across all namespaces in the Kubernetes cluster where you've been working with ResourceQuotas and pods, including the one running the busybox image.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The command `kubectl get pods --all-namespaces` lists all pods across all namespaces, helping to identify pods, including those running specific images like busybox, even in environments using ResourceQuotas.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::149",
    "prompt": "List all pods in the 'kube-system' namespace",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get pods -n kube-system",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Shows core control-plane and system Pods managed by Kubernetes in the `kube-system` namespace, used for health checks or troubleshooting.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get pods -n kube-system",
      "category": "Namespace Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::150",
    "prompt": "List all resources across all namespaces",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get all -A",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Aggregates Pods, Services, Deployments, ReplicaSets, and more from every namespace, giving a cluster-wide resource snapshot.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get all -A",
      "category": "Namespace Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::151",
    "prompt": "List all secrets",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get secrets",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Shows Secret names and types; data is hidden by default to protect sensitive values.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get secrets",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::152",
    "prompt": "List all services",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get services",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Enumerates Services in the namespace, including ClusterIP, NodePort, and LoadBalancer types.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get services",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::153",
    "prompt": "List daemonsets using the short alias",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "k get ds",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Uses `ds` as the short resource name for DaemonSets with the `k` alias to view all DaemonSets.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "k get ds",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::154",
    "prompt": "List pods using the 'kgp' alias",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kgp",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Runs `kubectl get pods` via the `kgp` alias to display all Pods in the current namespace.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kgp",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::155",
    "prompt": "List pods with status phase=Running",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get pods --field-selector=status.phase=Running",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Filters Pods based on their status field, showing only those in `Running` phase.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get pods --field-selector=status.phase=Running",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::156",
    "prompt": "List replicasets using the short alias",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "k get rs",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Uses `rs` as the short resource name for ReplicaSets with the `k` alias for a quick listing.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "k get rs",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::157",
    "prompt": "List secrets using the short alias",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "k get secret",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Runs `kubectl get secret` with the `k` alias to display all Secrets.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "k get secret",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::158",
    "prompt": "List services using the 'kgs' alias",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kgs",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Runs `kubectl get svc` via the `kgs` alias to display all Services in the current namespace.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kgs",
      "category": "Shell Setup: Aliases & Autocomplete",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::159",
    "prompt": "Mount a ConfigMap as a volume in a pod at path /etc/config with specific file permissions",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run config-pod --image=nginx --dry-run=client -o yaml > pod.yaml # then add volume with defaultMode",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Emits a Pod manifest to `pod.yaml`; edit its `spec.volumes` and `volumeMounts` to mount `app-config` at `/etc/config` with `defaultMode` for Unix file bits.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run config-pod --image=nginx --dry-run=client -o yaml > pod.yaml # then add volume with defaultMode",
      "category": "ConfigMap Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::160",
    "prompt": "Move to the end of the line",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "$",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Jumps the cursor to the last character of the current line.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "$",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::161",
    "prompt": "Move to the end of the word",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "e",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Advances the cursor to the end of the current or next word.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "e",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::162",
    "prompt": "Move to the first character of the line",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "0",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Places the cursor at column 0 of the current line.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "0",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::163",
    "prompt": "Move to the next word",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "w",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Jumps the cursor to the start of the next word.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "w",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::164",
    "prompt": "Move to the previous word",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "b",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Moves the cursor back to the beginning of the previous word.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "b",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::166",
    "prompt": "Open or create the file app.yaml in Vim",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "vim app.yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Launches Vim for `app.yaml`, creating it if missing—standard file-edit workflow.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "vim app.yaml",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::167",
    "prompt": "Open service.yaml in Vim",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "vim service.yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Edits the `service.yaml` manifest file locally to adjust port mappings, selectors, or Service types.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "vim service.yaml",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::168",
    "prompt": "Open the file app.yaml in Vim",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "vim app.yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Launches the `app.yaml` manifest in Vim, letting you edit Kubernetes specs directly in your terminal editor.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "vim app.yaml",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::170",
    "prompt": "Paste after the cursor",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "p",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Inserts the contents of the unnamed register after the cursor’s position.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "p",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::171",
    "prompt": "Pause the rollout of a deployment named 'frontend'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout pause deployment/frontend",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Temporarily halts `frontend`’s rolling update, giving you time to inspect or modify the Deployment spec before resuming.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl rollout pause deployment/frontend",
      "category": "Deployment Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::172",
    "prompt": "Port-forward local port 8080 to port 80 on service frontend-svc",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl port-forward service/frontend-svc 8080:80",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Tunnels traffic from your machine’s port 8080 to the Service’s clusterIP on port 80, enabling local access without exposing NodePorts.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl port-forward service/frontend-svc 8080:80",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::173",
    "prompt": "Q: Create a Pod named `config-pod` using the `busybox` image that mounts a ConfigMap named `app-config` as a volume at `/etc/config`",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run config-pod --image=busybox --dry-run=client -o yaml > pod.yaml # add volume and volumeMount",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Outputs a BusyBox Pod manifest to `pod.yaml`; edit its `spec.volumes` to reference `configMap.name: app-config` and `spec.containers[0].volumeMounts` to mount it at `/etc/config`, injecting config files at runtime.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run config-pod --image=busybox --dry-run=client -o yaml > pod.yaml # add volume and volumeMount",
      "category": "Pod Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::174",
    "prompt": "Quit without saving",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":q!",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Exits Vim discarding any unsaved edits.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": ":q!",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::175",
    "prompt": "Redo the last undone change",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "<C-r>",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Re-applies the last undone change in Vim’s redo stack.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "<C-r>",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::176",
    "prompt": "Remove the annotation description from deployment frontend",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl annotate deployment frontend description-",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Removes the `description` annotation, cleaning up auxiliary metadata.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl annotate deployment frontend description-",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::177",
    "prompt": "Remove the label env from pod busybox",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl label pod busybox env-",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Deletes the `env` label from `busybox`, updating its metadata in-place.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl label pod busybox env-",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::178",
    "prompt": "Replace configmap using file configmap.yaml",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl replace -f configmap.yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Atomically replaces the existing ConfigMap with the contents of `configmap.yaml`; fails if none exists.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl replace -f configmap.yaml",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::179",
    "prompt": "Restart the deployment frontend",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout restart deployment frontend",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Triggers a rolling restart of all Pods in `frontend`, useful for picking up new ConfigMaps or Secrets.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl rollout restart deployment frontend",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::180",
    "prompt": "Resume the rollout of a deployment named 'frontend'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout resume deployment/frontend",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Continues a paused rollout for the `frontend` Deployment, applying any pending Pod template changes.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl rollout resume deployment/frontend",
      "category": "Deployment Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::181",
    "prompt": "Retrieve the YAML configuration of the nginx pod, which was initially created with the nginx image, named nginx, exposed to receive traffic on port 80, and later had its image updated to nginx:1.24.0.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "true",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The command `kubectl get pod nginx -o yaml` retrieves the current configuration of the nginx pod in YAML format, showing its latest state including any updates like the image change to nginx:1.24.0.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/md/a.core_concepts.md"
    }
  },
  {
    "id": "master_quiz_with_explanations::182",
    "prompt": "Roll back a deployment named 'webapp' to its previous version",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout undo deployment/webapp",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Reverts the `webapp` Deployment to its prior revision, restoring previous Pod templates and undoing the last `set image` or `apply` change.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl rollout undo deployment/webapp",
      "category": "Deployment Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::183",
    "prompt": "Roll back the deployment frontend to the previous version",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout undo deployment frontend",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Reverts `frontend` to its last successful revision, undoing the most recent spec change.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl rollout undo deployment frontend",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::184",
    "prompt": "Run a pod named busybox with image busybox that runs indefinitely",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run busybox --image=busybox --restart=Never -- /bin/sh -c \"sleep 3600\"",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Creates a Pod that sleeps for an hour, with `--restart=Never` so it won’t loop—handy for test or debug scenarios.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl run busybox --image=busybox --restart=Never -- /bin/sh -c \"sleep 3600\"",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::185",
    "prompt": "Save and quit Vim",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":wq",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Writes buffer changes to disk and exits Vim.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": ":wq",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::188",
    "prompt": "Scale a deployment named 'frontend' to 5 replicas",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl scale deployment frontend --replicas=5",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Adjusts the `frontend` Deployment’s replica count to 5, prompting the ReplicaSet controller to create or remove Pods to match the desired state.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl scale deployment frontend --replicas=5",
      "category": "Deployment Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::189",
    "prompt": "Scale deployment frontend to 3 replicas",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl scale deployment frontend --replicas=3",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Adjusts the target replica count for `frontend`, prompting creation or termination of Pods.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl scale deployment frontend --replicas=3",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::191",
    "prompt": "Set the KUBECONFIG environment variable to /home/user/config",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "export KUBECONFIG=/home/user/config",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Points the `kubectl` client at a non-default kubeconfig file, useful when managing multiple clusters or contexts.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "export KUBECONFIG=/home/user/config",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::192",
    "prompt": "Set the current context to use the 'production' namespace by default",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl config set-context --current --namespace=production",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Mutates your active kubeconfig context so that subsequent `kubectl` commands default to `production` unless overridden with `-n`.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl config set-context --current --namespace=production",
      "category": "Namespace Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::193",
    "prompt": "Set the namespace to dev in the current context",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl config set-context --current --namespace=dev",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Alters your default namespace for the current context so that `kubectl get pods` goes to `dev` by default.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl config set-context --current --namespace=dev",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::194",
    "prompt": "Show available API resource types",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl api-resources",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Lists every resource kind the API server supports, including short names and whether they’re namespaced.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl api-resources",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::195",
    "prompt": "Show only context names",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl config get-contexts -o name",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Outputs just the context identifiers, ideal for scripting or building dynamic prompt menus.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl config get-contexts -o name",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::196",
    "prompt": "Show resource usage of nodes",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl top nodes",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Lists CPU and memory utilization across nodes, helping identify saturation or under-utilization.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl top nodes",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::197",
    "prompt": "Show resource usage of pods",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl top pods",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Displays CPU and memory metrics for each Pod (requires Metrics Server in the cluster).",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl top pods",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::198",
    "prompt": "Solve this question on instance: ssh ckad5601\nCreate a new PersistentVolume named earth-project-earthflower-pv. It should have a capacity of 2Gi, accessMode ReadWriteOnce, hostPath /Volumes/Data and no storageClassName defined.\nNext create a new PersistentVolumeClaim in Namespace earth named earth-project-earthflower-pvc . It should request 2Gi storage, accessMode ReadWriteOnce and should not define a storageClassName. The PVC should bound to the PV correctly.\nFinally create a new Deployment project-earthflower in Namespace earth which mounts that volume at /tmp/project-data. The Pods of that Deployment should be of image httpd:2.4.41-alpine.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Creating a PersistentVolume (PV) with specified capacity and access modes allows for storage to be provisioned for use by Pods, while a PersistentVolumeClaim (PVC) in the same namespace with matching specifications ensures a binding between the volume and the claim, enabling the Deployment to mount the volume at a specified path, using a specific image for its Pods.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::199",
    "prompt": "Solve this question on instance: ssh ckad5601\nCreate a single Pod named pod6 in Namespace default of image busybox:1.31.0. The Pod should have a readiness-probe executing cat /tmp/ready. It should initially wait 5 and periodically wait 10 seconds. This will set the container ready only if the file /tmp/ready exists.\nThe Pod should run the command touch /tmp/ready && sleep 1d, which will create the necessary file to be ready and then idles. Create the Pod and confirm it starts.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The command creates a Pod named 'pod6' using the 'busybox:1.31.0' image, with a readiness probe that checks for the existence of '/tmp/ready' to determine if the Pod is ready to handle traffic, ensuring the Pod only receives traffic when the file exists, demonstrating how readiness probes are used to manage traffic flow to Pods based on their state.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::200",
    "prompt": "Solve this question on instance: ssh ckad5601\nCreate a single Pod of image httpd:2.4.41-alpine in Namespace default. The Pod should be named pod1 and the container should be named pod1-container.\nYour manager would like to run a command manually on occasion to output the status of that exact Pod. Please write a command that does this into /opt/course/2/pod1-status-command.sh on ckad5601. The command should use kubectl.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The correct command to output the status of a specific pod named pod1 in the default namespace is `kubectl get pod pod1 -n default -o wide`, which retrieves detailed information about pod1, including its status, IP address, and the node it's running on, helping to quickly assess its current state.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::201",
    "prompt": "Solve this question on instance: ssh ckad5601\nIn Namespace jupiter you'll find an apache Deployment (with one replica) named jupiter-crew-deploy and a ClusterIP Service called jupiter-crew-svc which exposes it. Change this service to a NodePort one to make it available on all nodes on port 30100.\nTest the NodePort Service using the internal IP of all available nodes and the port 30100 using curl, you can reach the internal node IPs directly from your main terminal. On which nodes is the Service reachable? On which node is the Pod running?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Changing a service to NodePort in Kubernetes exposes it on a specific port across all nodes, allowing external access to the service through any node's IP address at the specified port, in this case, 30100. This makes the service reachable from outside the cluster, facilitating testing and access without needing to know the specific pod's location.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::202",
    "prompt": "Solve this question on instance: ssh ckad5601\nLast lunch you told your coworker from department Mars Inc how amazing InitContainers are. Now he would like to see one in action. There is a Deployment yaml at /opt/course/17/test-init-container.yaml. This Deployment spins up a single Pod of image nginx:1.17.3-alpine and serves files from a mounted volume, which is empty right now.\nCreate an InitContainer named init-con which also mounts that volume and creates a file index.html with content check this out! in the root of the mounted volume. For this test we ignore that it doesn't contain valid html.\nThe InitContainer should be using image busybox:1.31.0. Test your implementation for example using curl from a temporary nginx:alpine Pod.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "InitContainers are special containers that run before app containers in a Pod, used here to prepare a volume with specific data (an index.html file) before the main nginx container serves it, demonstrating their utility in initializing or setting up prerequisites for an application's primary containers.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::203",
    "prompt": "Solve this question on instance: ssh ckad5601\nThere seems to be an issue in Namespace mars where the ClusterIP service manager-api-svc should make the Pods of Deployment manager-api-deployment available inside the cluster.\nYou can test this with curl manager-api-svc.mars:4444 from a temporary nginx:alpine Pod. Check for the misconfiguration and apply a fix.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Creating a temporary nginx:alpine Pod and using curl to test the service's connectivity allows for diagnosing issues with service exposure or networking within the specified namespace, ensuring the service is correctly routing requests to the pods of the deployment.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::204",
    "prompt": "Solve this question on instance: ssh ckad7326\nIn Namespace venus you'll find two Deployments named api and frontend. Both Deployments are exposed inside the cluster using Services. Create a NetworkPolicy named np1 which restricts outgoing tcp connections from Deployment frontend and only allows those going to Deployment api. Make sure the NetworkPolicy still allows outgoing traffic on UDP/TCP ports 53 for DNS resolution.\nTest using: wget www.google.com and wget api:2222 from a Pod of Deployment frontend.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Creating a NetworkPolicy named np1 to restrict outgoing TCP connections from the frontend Deployment to only allow connections to the api Deployment, while ensuring DNS resolution can occur, involves defining specific egress rules that target the api service's labels for TCP traffic and allow all traffic on UDP/TCP port 53 for DNS queries.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::205",
    "prompt": "Solve this question on instance: ssh ckad7326\nTeam Mercury asked you to perform some operations using Helm, all in Namespace mercury:\nDelete release internal-issue-report-apiv1\nUpgrade release internal-issue-report-apiv2 to any newer version of chart bitnami/nginx available\nInstall a new release internal-issue-report-apache of chart bitnami/apache. The Deployment should have two replicas, set these via Helm-values during install\nThere seems to be a broken release, stuck in pending-install state. Find it and delete it",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "To address the tasks, you would use Helm commands to manage releases within a Kubernetes cluster: deleting a specified release with `helm delete`, upgrading another with `helm upgrade` using a newer chart version, installing a new release with `helm install` while specifying values for the desired number of replicas, and identifying then deleting a release in a `pending-install` state, showcasing Helm's capabilities in application lifecycle management in a Kubernetes environment.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::206",
    "prompt": "Solve this question on instance: ssh ckad7326\nTeam Neptune has its own ServiceAccount named neptune-sa-v2 in Namespace neptune. A coworker needs the token from the Secret that belongs to that ServiceAccount. Write the base64 decoded token to file /opt/course/5/token on ckad7326.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "To retrieve the token for a ServiceAccount, you must first identify the Secret associated with that ServiceAccount, extract the token field from the Secret, decode it from base64, and then write it to the specified file, demonstrating how Kubernetes ServiceAccounts are linked to Secrets for authentication purposes.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::207",
    "prompt": "Solve this question on instance: ssh ckad7326\nTeam Neptune needs 3 Pods of image httpd:2.4-alpine, create a Deployment named neptune-10ab for this. The containers should be named neptune-pod-10ab. Each container should have a memory request of 20Mi and a memory limit of 50Mi.\nTeam Neptune has its own ServiceAccount neptune-sa-v2 under which the Pods should run. The Deployment should be in Namespace neptune.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "To address the scenario, you would create a Deployment in Kubernetes specifying the image, the number of replicas, container name, memory requests and limits, and the ServiceAccount under which the Pods should run, all within the specified namespace, to ensure the Pods are deployed according to the team's requirements.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::208",
    "prompt": "Solve this question on instance: ssh ckad7326\nTeam Neptune needs a Job template located at /opt/course/3/job.yaml. This Job should run image busybox:1.31.0 and execute sleep 2 && echo done. It should be in namespace neptune, run a total of 3 times and should execute 2 runs in parallel.\nStart the Job and check its history. Each pod created by the Job should have the label id: awesome-job. The job should be named neb-new-job and the container neb-new-job-container.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "To address the requirements, you need to modify the job.yaml file to specify the busybox:1.31.0 image, the command to execute, and the namespace. The job's spec should include `completions: 3` for the total runs, `parallelism: 2` for concurrent executions, and `labels: id: awesome-job` for pod identification. The job and container names are set in the metadata and container spec, respectively. After applying the job with `kubectl apply`, use `kubectl get pods --selector=id=awesome-job --namespace=neptune` to check the job's pod history, ensuring all specifications are met.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::209",
    "prompt": "Solve this question on instance: ssh ckad7326\nThe Tech Lead of Mercury2D decided it's time for more logging, to finally fight all these missing data incidents. There is an existing container named cleaner-con in Deployment cleaner in Namespace mercury. This container mounts a volume and writes logs into a file called cleaner.log.\nThe yaml for the existing Deployment is available at /opt/course/16/cleaner.yaml. Persist your changes at /opt/course/16/cleaner-new.yaml on ckad7326 but also make sure the Deployment is running.\nCreate a sidecar container named logger-con, image busybox:1.31.0 , which mounts the same volume and writes the content of cleaner.log to stdout, you can use the tail -f command for this. This way it can be picked up by kubectl logs.\nCheck if the logs of the new container reveal something about the missing data incidents.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Adding a sidecar container like logger-con to the Deployment allows for real-time monitoring of log files by leveraging the tail command to continuously output the log file's content to stdout, making it accessible through Kubernetes' logging mechanisms.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::210",
    "prompt": "Solve this question on instance: ssh ckad7326\nThe board of Team Neptune decided to take over control of one e-commerce webserver from Team Saturn. The administrator who once setup this webserver is not part of the organisation any longer. All information you could get was that the e-commerce system is called my-happy-shop.\nSearch for the correct Pod in Namespace saturn and move it to Namespace neptune. It doesn't matter if you shut it down and spin it up again, it probably hasn't any customers anyways.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "To move a pod from one namespace to another in Kubernetes, you must first delete the existing pod in the current namespace and then recreate it in the target namespace, as pods cannot be directly moved between namespaces.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::211",
    "prompt": "Solve this question on instance: ssh ckad7326\nThere is an existing Deployment named api-new-c32 in Namespace neptune. A developer did make an update to the Deployment but the updated version never came online. Check the Deployment history and find a revision that works, then rollback to it. Could you tell Team Neptune what the error was so it doesn't happen again?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "To troubleshoot and fix the issue, use `kubectl rollout history deployment api-new-c32 --namespace=neptune` to view the deployment's revision history, identify a working revision, and then rollback using `kubectl rollout undo deployment api-new-c32 --to-revision=<revision_number> --namespace=neptune`, which restores the deployment to a previous, stable state, helping to avoid downtime caused by the failed update.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::212",
    "prompt": "Solve this question on instance: ssh ckad9043\nIn Namespace pluto there is single Pod named holy-api. It has been working okay for a while now but Team Pluto needs it to be more reliable.\nConvert the Pod into a Deployment named holy-api with 3 replicas and delete the single Pod once done. The raw Pod template file is available at /opt/course/9/holy-api-pod.yaml.\nIn addition, the new Deployment should set allowPrivilegeEscalation: false and privileged: false for the security context on container level.\nPlease create the Deployment and save its yaml under /opt/course/9/holy-api-deployment.yaml on ckad9043.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Converting a Pod into a Deployment ensures that the desired number of pod replicas are maintained, enhancing reliability by allowing Kubernetes to automatically replace instances that fail or are terminated. Editing the Pod template to include specific security contexts enhances the security posture by restricting the privileges of the container, aligning with best practices for container security. Deleting the original Pod after creating the Deployment avoids potential conflicts and ensures that only the managed pods are running. Saving the Deployment's YAML file allows for version control and documentation of the infrastructure configuration.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::213",
    "prompt": "Solve this question on instance: ssh ckad9043\nTeam Moonpie has a nginx server Deployment called web-moon in Namespace moon. Someone started configuring it but it was never completed. To complete please create a ConfigMap called configmap-web-moon-html containing the content of file /opt/course/15/web-moon.html under the data key-name index.html.\nThe Deployment web-moon is already configured to work with this ConfigMap and serve its content. Test the nginx configuration for example using curl from a temporary nginx:alpine Pod.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Creating a ConfigMap named configmap-web-moon-html with the content of /opt/course/15/web-moon.html under the data key-name index.html allows the Deployment web-moon to dynamically load and serve the specified HTML content through nginx, leveraging Kubernetes' ability to inject configuration data into Pods.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::214",
    "prompt": "Solve this question on instance: ssh ckad9043\nTeam Moonpie, which has the Namespace moon, needs more storage. Create a new PersistentVolumeClaim named moon-pvc-126 in that namespace. This claim should use a new StorageClass moon-retain with the provisioner set to moon-retainer and the reclaimPolicy set to Retain. The claim should request storage of 3Gi, an accessMode of ReadWriteOnce and should use the new StorageClass.\nThe provisioner moon-retainer will be created by another team, so it's expected that the PVC will not boot yet. Confirm this by writing the event message from the PVC into file /opt/course/13/pvc-126-reason on ckad9043.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Creating a PersistentVolumeClaim (PVC) with specific parameters such as storage class, access modes, and storage size allows users to request storage resources in Kubernetes, ensuring that applications have the necessary storage capacity and characteristics they require, while the use of a custom provisioner and retention policy allows for tailored storage management and data persistence strategies.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::215",
    "prompt": "Solve this question on instance: ssh ckad9043\nTeam Pluto needs a new cluster internal Service. Create a ClusterIP Service named project-plt-6cc-svc in Namespace pluto. This Service should expose a single Pod named project-plt-6cc-api of image nginx:1.17.3-alpine, create that Pod as well. The Pod should be identified by label project: plt-6cc-api. The Service should use tcp port redirection of 3333:80.\nFinally use for example curl from a temporary nginx:alpine Pod to get the response from the Service. Write the response into /opt/course/10/service_test.html on ckad9043. Also check if the logs of Pod project-plt-6cc-api show the request and write those into /opt/course/10/service_test.log on ckad9043.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The scenario involves creating a Pod and a ClusterIP Service in Kubernetes to expose the Pod within the cluster, then testing the connectivity to this Service from another temporary Pod, demonstrating how to set up internal communication between Pods and how to log and verify that communication.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::216",
    "prompt": "Solve this question on instance: ssh ckad9043\nTeam Sunny needs to identify some of their Pods in namespace sun. They ask you to add a new label protected: true to all Pods with an existing label type: worker or type: runner. Also add an annotation protected: do not delete this pod to all Pods having the new label protected: true.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Labeling and annotating pods in Kubernetes allows for the organization, management, and selection of pods based on specified criteria, enabling more efficient resource handling and policy enforcement.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::217",
    "prompt": "Solve this question on instance: ssh ckad9043\nThere are files to build a container image located at /opt/course/11/image on ckad9043. The container will run a Golang application which outputs information to stdout. You're asked to perform the following tasks:\nℹ️ Run all Docker and Podman commands as user root. Use sudo docker and sudo podman or become root with sudo -i\nChange the Dockerfile: set ENV variable SUN_CIPHER_ID to hardcoded value 5b9c1065-e39d-4a43-a04a-e59bcea3e03f\nBuild the image using sudo docker, tag it registry.killer.sh:5000/sun-cipher:v1-docker and push it to the registry\nBuild the image using sudo podman, tag it registry.killer.sh:5000/sun-cipher:v1-podman and push it to the registry\nRun a container using sudo podman, which keeps running detached in the background, named sun-cipher using image registry.killer.sh:5000/sun-cipher:v1-podman\nWrite the logs your container sun-cipher produces into /opt/course/11/logs on ckad9043",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The scenario involves modifying a Dockerfile to set an environment variable, building and tagging the container image with both Docker and Podman, pushing these images to a registry, running a container in detached mode, and saving its stdout logs to a file, demonstrating proficiency in container image management and runtime operations.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::218",
    "prompt": "Solve this question on instance: ssh ckad9043\nYou need to make changes on an existing Pod in Namespace moon called secret-handler. Create a new Secret secret1 which contains user=test and pass=pwd. The Secret's content should be available in Pod secret-handler as environment variables SECRET1_USER and SECRET1_PASS. The yaml for Pod secret-handler is available at /opt/course/14/secret-handler.yaml.\nThere is existing yaml for another Secret at /opt/course/14/secret2.yaml, create this Secret and mount it inside the same Pod at /tmp/secret2. Your changes should be saved under /opt/course/14/secret-handler-new.yaml on ckad9043. Both Secrets should only be available in Namespace moon.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "The scenario requires creating a new Secret with specific key-value pairs, updating an existing Pod to inject the Secret's data as environment variables, and mounting another Secret from a provided YAML file, demonstrating how to manage sensitive data and configure Pods to use Secrets in Kubernetes.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "This is a complex scenario. Follow the prompt instructions on the specified instance.",
      "category": "Advanced Scenarios",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::219",
    "prompt": "Switch kubectl context to minikube",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl config use-context minikube",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Sets the active context to `minikube`, directing subsequent commands to your local Minikube cluster.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl config use-context minikube",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::220",
    "prompt": "The provided YAML is for a basic pod. Modify it to create a pod named 'nginx-live' that uses the 'nginx:stable' image.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {
      "pod.yaml": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod\nspec:\n  containers:\n  - name: main\n    image: busybox\n    command: [\"sleep\", \"3600\"]"
    },
    "validation_steps": [
      {
        "cmd": "#!/bin/bash\nset -e\nkubectl apply -f pod.yaml\n# Check pod name\nPOD_NAME=$(kubectl get pods -o jsonpath='{.items[0].metadata.name}')\nif [ \"$POD_NAME\" != \"nginx-live\" ]; then\n  echo \"Error: Pod name is '$POD_NAME', expected 'nginx-live'\"\n  exit 1\nfi\n# Check image\nIMAGE=$(kubectl get pod nginx-live -o jsonpath='{.spec.containers[0].image}')\nif [ \"$IMAGE\" != \"nginx:stable\" ]; then\n  echo \"Error: Image is '$IMAGE', expected 'nginx:stable'\"\n  exit 1\nfi\necho \"Pod 'nginx-live' with image 'nginx:stable' found.\"",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "To solve this, you need to change the `metadata.name` to 'nginx-live' and the `spec.containers[0].image` to 'nginx:stable'.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "category": "Live Kubernetes Questions",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::222",
    "prompt": "Undo the last change",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "u",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Reverts the most recent edit in Vim’s undo history.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "u",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::223",
    "prompt": "Update a value in an existing ConfigMap named 'app-config'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl edit cm app-config",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Opens the live ConfigMap in your default editor, letting you change keys inline; upon save, Kubernetes replaces the resource atomically.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl edit cm app-config",
      "category": "ConfigMap Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::224",
    "prompt": "Update the image of a deployment named 'webapp' to nginx:1.18",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl set image deployment/webapp webapp=nginx:1.18",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Patches the `webapp` Deployment to use `nginx:1.18`, triggering a rolling update that replaces old Pods with new ones in a controlled fashion.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl set image deployment/webapp webapp=nginx:1.18",
      "category": "Deployment Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::225",
    "prompt": "Use kubectl to edit deployment frontend",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl edit deployment frontend",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Fetches the live `frontend` Deployment into an editor, then patches it on save, providing an in-place live edit workflow.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl edit deployment frontend",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::226",
    "prompt": "Verify which namespace is currently being used in your context",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl config view --minify | grep namespace:",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Extracts the `namespace:` line from the minimized kubeconfig output, confirming the default target for your `kubectl` operations.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl config view --minify | grep namespace:",
      "category": "Namespace Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::227",
    "prompt": "View logs of container nginx in pod frontend-pod",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl logs frontend-pod -c nginx",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Specifies `-c nginx` to select the `nginx` container when a Pod has multiple containers, isolating its logs.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl logs frontend-pod -c nginx",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::228",
    "prompt": "View logs of pod busybox",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl logs busybox",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Streams the stdout/stderr logs from the `busybox` container, useful for simple log inspection when no sidecar is present.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl logs busybox",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::229",
    "prompt": "View the contents of a ConfigMap named 'db-config'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl describe cm db-config",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Shows detailed key/value pairs, creation timestamp, and events related to `db-config`, aiding in verification and debugging.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl describe cm db-config",
      "category": "ConfigMap Operations",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::230",
    "prompt": "View the current kubectl context",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl config current-context",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Prints the name of the active context from your kubeconfig, clarifying which cluster and namespace your commands target.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl config current-context",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::231",
    "prompt": "View the encoded values in a Secret named 'api-secrets'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get secret api-secrets -o yaml",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Prints `api-secrets`’s data fields in base64 form; decode locally via `echo '<value>' | base64 --decode` to inspect underlying values.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl get secret api-secrets -o yaml",
      "category": "Secret Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::232",
    "prompt": "View the history of a deployment named 'webapp'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout history deployment/webapp",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Lists all revisions of `webapp`, showing image versions and `change-cause` annotations to help audit past rollouts.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl rollout history deployment/webapp",
      "category": "Deployment Management",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::233",
    "prompt": "Watch the rollout status of deployment frontend",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout status deployment/frontend -w",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Streams updates on the `frontend` rollout, auto-refreshing until completion or error.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "kubectl rollout status deployment/frontend -w",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "master_quiz_with_explanations::234",
    "prompt": "Yank (copy) the current line",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "yy",
        "matcher": {
          "exit_code": 0
        }
      }
    ],
    "explanation": "Copies the entire line under the cursor into Vim’s unnamed register.",
    "categories": [],
    "difficulty": null,
    "metadata": {
      "response": "yy",
      "category": "Additional Commands",
      "source_file": "/Users/user/Documents/GitHub/kubelingo/scripts/../question-data/json/ckad_quiz_data_with_explanations.json"
    }
  },
  {
    "id": "killercoda_ckad_cheat_sheet::0",
    "prompt": "Steps",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "apiVersion: networking.k8s.io/v1\n   kind: NetworkPolicy\n   metadata:\n     name: np\n     namespace: space1\n   spec:\n     podSelector: {}\n     policyTypes:\n     - Egress\n     egress:\n     - to:\n       - namespaceSelector:\n           matchLabels:\n             kubernetes.io/metadata.name: space2\n       ports:\n       - port: 53\n         protocol: TCP\n       - port: 53\n         protocol: UDP",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "killercoda_ckad_cheat_sheet::1",
    "prompt": "I'm sorry, but you haven't provided the actual text for the first and second questions. Could you please share the specific questions you'd like to be rewritten?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "grep -- '--enable-admission-plugins' /etc/kubernetes/manifests/kube-apiserver.yaml > /root/admission-plugins",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "killercoda_ckad_cheat_sheet::2",
    "prompt": "I'm sorry, but you haven't provided the actual text for the question to be rewritten. Could you please share the specific question you'd like to be rewritten?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "cp /etc/kubernetes/manifests/kube-apiserver.yaml /root/kube-apiserver-backup.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "killercoda_ckad_cheat_sheet::3",
    "prompt": "What are the steps involved in the process described in the first question?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "cp /etc/kubernetes/manifests/kube-apiserver.yaml /root/kube-apiserver-nsl-backup.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "killercoda_ckad_cheat_sheet::4",
    "prompt": "What are the steps involved in deploying an application to Kubernetes?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl version --short | grep 'Server Version' | sed 's/.*Server Version: v//' | tr '.' '\\n' > /root/versions",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "killercoda_ckad_cheat_sheet::5",
    "prompt": "Based on the steps involved in deploying an application to Kubernetes, list them in detail.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl explain deployments | grep '^GROUP:' | awk '{print $2}' > /root/group",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "killercoda_ckad_cheat_sheet::6",
    "prompt": "What are the detailed steps involved in deploying an application to Kubernetes?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "cp /apps/cronjob.yaml /root/cronjob-backup.yaml\n   sed -i 's@batch/v1beta1@batch/v1@g' /apps/cronjob.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "killercoda_ckad_cheat_sheet::7",
    "prompt": "What are the detailed steps involved in deploying an application to Kubernetes, as previously described?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "cp /apps/flowschema.yaml /root/flowschema-backup.yaml\n   sed -i 's@flowcontrol.apiserver.k8s.io/v1beta1@flowcontrol.apiserver.k8s.io/v1@g' /apps/flowschema.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "g.state::0",
    "prompt": "Create busybox pod with two containers, each one will have the image busybox and will run the 'sleep 3600' command. Make both containers mount an emptyDir at '/etc/foo'. Connect to the second busybox, write the first column of '/etc/passwd' file to '/etc/foo/passwd'. Connect to the first busybox and write '/etc/foo/passwd' file to standard output. Delete pod.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run busybox --image=busybox --restart=Never -o yaml --dry-run=client -- /bin/sh -c 'sleep 3600' > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "g.state::1",
    "prompt": "Create a PersistentVolume named 'myvolume' with a size of 10Gi, supporting access modes 'ReadWriteOnce' and 'ReadWriteMany', and using the storageClassName 'normal'. This PersistentVolume should be configured to mount on hostPath '/etc/foo', replicating the setup from a previous task where a busybox pod with two containers was created to share an emptyDir volume at '/etc/foo'. Write the PersistentVolume configuration to a file named pv.yaml and apply it to your Kubernetes cluster. Afterward, display the list of PersistentVolumes currently available in the cluster.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "vi pv.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "g.state::2",
    "prompt": "Create a PersistentVolumeClaim named 'mypvc' to use with the existing PersistentVolume 'myvolume'. The 'myvolume' PersistentVolume was previously created with a size of 10Gi, supports access modes 'ReadWriteOnce' and 'ReadWriteMany', and uses the storageClassName 'normal'. Configure 'mypvc' with a request for 4Gi, an access mode of ReadWriteOnce, and the same storageClassName 'normal'. Write the PersistentVolumeClaim configuration to a file named pvc.yaml and apply it to your Kubernetes cluster. Afterward, display the list of PersistentVolumeClaims and the list of PersistentVolumes currently available in the cluster.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "vi pvc.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "g.state::3",
    "prompt": "Create a busybox pod with the command 'sleep 3600' and save the configuration to a file named pod.yaml. Mount the PersistentVolumeClaim 'mypvc', which was configured with a request for 4Gi, an access mode of ReadWriteOnce, and with the storageClassName 'normal', to the directory '/etc/foo' within the pod. After the pod is running, connect to the 'busybox' pod and copy the '/etc/passwd' file to '/etc/foo/passwd'.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run busybox --image=busybox --restart=Never -o yaml --dry-run=client -- /bin/sh -c 'sleep 3600' > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "g.state::4",
    "prompt": "Create a second busybox pod with the command 'sleep 3600,' ensuring it mounts the PersistentVolumeClaim 'mypvc'—which is configured with a request for 4Gi, an access mode of ReadWriteOnce, and with the storageClassName 'normal'—to the directory '/etc/foo,' similarly to the first pod you created as described. Save the configuration to a file with a different name, ensuring you change only the 'name' property of the pod in your YAML file. After the pod is running, connect to this new busybox pod and verify that '/etc/foo' contains the 'passwd' file, which was previously copied to this location in the first pod. Delete both pods to clean up after the verification. If you cannot see the 'passwd' file from the second pod, identify the reason why it might not be visible and propose a solution to fix this issue.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "vim pod.yaml\n# change 'metadata.name: busybox' to 'metadata.name: busybox2'\nkubectl create -f pod.yaml\nkubectl exec busybox2 -- ls /etc/foo # will show 'passwd'\n# cleanup\nkubectl delete po busybox busybox2\nkubectl delete pvc mypvc\nkubectl delete pv myvolume",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "g.state::5",
    "prompt": "Create a busybox pod with the command 'sleep 3600,' ensuring it mounts the same PersistentVolumeClaim 'mypvc'—configured with a request for 4Gi, an access mode of ReadWriteOnce, and with the storageClassName 'normal'—to the directory '/etc/foo'. After the pod is running, copy '/etc/passwd' to '/etc/foo' within the pod, and then copy '/etc/foo/passwd' from the pod to your local folder.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run busybox --image=busybox --restart=Never -- sleep 3600\nkubectl cp busybox:/etc/passwd ./passwd # kubectl cp command\n# previous command might report an error, feel free to ignore it since copy command works\ncat passwd",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::0",
    "prompt": "Create 3 pods with names nginx1,nginx2,nginx3. All of them should have the label app=v1",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx1 --image=nginx --restart=Never --labels=app=v1\nkubectl run nginx2 --image=nginx --restart=Never --labels=app=v1\nkubectl run nginx3 --image=nginx --restart=Never --labels=app=v1\n# or\nfor i in `seq 1 3`; do kubectl run nginx$i --image=nginx -l app=v1 ; done",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::1",
    "prompt": "Show all labels of the pods named nginx1, nginx2, and nginx3, which were created with the label app=v1.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get po --show-labels",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::2",
    "prompt": "Change the labels of the pod named 'nginx2', which was originally created with the label app=v1, to be app=v2.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl label po nginx2 app=v2 --overwrite\n# or edit the pod yaml\nkubectl edit po nginx2",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::3",
    "prompt": "After changing the labels of the pod named 'nginx2', which was originally created with the label app=v1, to app=v2, retrieve the label 'app' for the pods by showing a column with APP labels.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get po -L app\n# or\nkubectl get po --label-columns=app",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::4",
    "prompt": "Retrieve only the pods labeled with 'app=v2', assuming a scenario where the label of a pod named 'nginx2', originally labeled 'app=v1', was changed to 'app=v2'.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get po -l app=v2\n# or\nkubectl get po -l 'app in (v2)'\n# or\nkubectl get po --selector=app=v2",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::5",
    "prompt": "Retrieve only the pods labeled with 'app=v2' but exclude those labeled with 'tier=frontend', including a scenario where a pod named 'nginx2' was originally labeled 'app=v1' and then had its label changed to 'app=v2'.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get po -l app=v2,tier!=frontend\n# or\nkubectl get po -l 'app in (v2), tier notin (frontend)'\n# or\nkubectl get po --selector=app=v2,tier!=frontend",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::6",
    "prompt": "Add a new label tier=web to all pods initially labeled with either 'app=v1' or 'app=v2', including pods like 'nginx2' which was originally labeled 'app=v1' but then had its label changed to 'app=v2'.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl label po -l \"app in(v1,v2)\" tier=web",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::7",
    "prompt": "Add an annotation 'owner: marketing' to all pods initially labeled with either 'app=v1' or 'app=v2', including pods like 'nginx2' which was originally labeled 'app=v1' but then had its label changed to 'app=v2', currently having 'app=v2' label.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl annotate po -l \"app=v2\" owner=marketing",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::8",
    "prompt": "Remove the 'app' label from all pods that were initially labeled with either 'app=v1' or 'app=v2' and had the annotation 'owner: marketing' added, including pods like those initially labeled 'app=v1' but then had their label changed to 'app=v2'.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl label po nginx1 nginx2 nginx3 app-\n# or\nkubectl label po nginx{1..3} app-\n# or\nkubectl label po -l app app-",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::9",
    "prompt": "Annotate pods nginx1, nginx2, nginx3, which are among the pods that had either 'app=v1' or 'app=v2' labels and were annotated with 'owner: marketing', with \"description='my description'\" value.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl annotate po nginx1 nginx2 nginx3 description='my description'\n\n#or\n\nkubectl annotate po nginx{1..3} description='my description'",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::10",
    "prompt": "Check the annotations for pod nginx1, ensuring it includes the \"description='my description'\" value, following its annotation along with pods nginx2 and nginx3, which had been previously selected for annotation because they had either 'app=v1' or 'app=v2' labels and were also annotated with 'owner: marketing'.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl annotate pod nginx1 --list\n\n# or\n\nkubectl describe po nginx1 | grep -i 'annotations'\n\n# or\n\nkubectl get po nginx1 -o custom-columns=Name:metadata.name,ANNOTATIONS:metadata.annotations.description",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::11",
    "prompt": "Remove the annotations for the three pods, nginx1, nginx2, and nginx3, previously annotated because they either had 'app=v1' or 'app=v2' labels and were annotated with 'owner: marketing', including ensuring that nginx1's annotation also had the \"description='my description'\" value.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl annotate po nginx{1..3} description- owner-",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::12",
    "prompt": "Remove the three pods named nginx1, nginx2, and nginx3 from your cluster to ensure a clean state, following their previous annotation updates due to having either 'app=v1' or 'app=v2' labels and a specific annotation for nginx1 with 'owner: marketing' and \"description='my description'\".",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl delete po nginx{1..3}",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::13",
    "prompt": "Create a pod that will be deployed to a Node that has the label 'accelerator=nvidia-tesla-p100', considering you have just ensured a clean state by removing three pods named nginx1, nginx2, and nginx3 from your cluster following updates to their annotations and labels.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl label nodes <your-node-name> accelerator=nvidia-tesla-p100\nkubectl get nodes --show-labels",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::14",
    "prompt": "Taint a node with the key `tier` and value `frontend` with the effect `NoSchedule`. Then, create a pod that tolerates this taint, ensuring that this new pod also meets the criterion from a previous task: it should be deployable to a Node that has the label `accelerator=nvidia-tesla-p100`.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl taint node node1 tier=frontend:NoSchedule # key=value:Effect\nkubectl describe node node1 # view the taints on a node",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::15",
    "prompt": "Create a pod that will be placed on the node `controlplane` by using nodeSelector to ensure it targets a node with the label `accelerator=nvidia-tesla-p100`. Additionally, the pod should include tolerations to allow it to be scheduled on a node tainted with the key `tier`, value `frontend`, and effect `NoSchedule`.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "vi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::16",
    "prompt": "Create a deployment called nginx, using the image nginx:1.18.0, with 2 replicas. Define port 80 as the port that the container exposes. This deployment should also include specifications so that pods are placed on a node labeled with `accelerator=nvidia-tesla-p100` by using a nodeSelector, and include tolerations to allow the pods to be scheduled on a node tainted with the key `tier`, value `frontend`, and effect `NoSchedule`. Do not create a service for this deployment.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create deployment nginx  --image=nginx:1.18.0  --dry-run=client -o yaml > deploy.yaml\nvi deploy.yaml\n# change the replicas field from 1 to 2\n# add this section to the container spec and save the deploy.yaml file\n# ports:\n#   - containerPort: 80\nkubectl apply -f deploy.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::17",
    "prompt": "View the YAML of the deployment called nginx, which uses the image nginx:1.18.0, with 2 replicas, defines port 80 as the port that the container exposes, includes a nodeSelector to place pods on a node labeled with `accelerator=nvidia-tesla-p100`, and includes tolerations to allow the pods to be scheduled on a node tainted with the key `tier`, value `frontend`, and effect `NoSchedule`.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get deploy nginx -o yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::18",
    "prompt": "View the YAML of the replica set that was created by the deployment called nginx, which uses the image nginx:1.18.0, with 2 replicas, defines port 80 as the port that the container exposes, includes a nodeSelector to place pods on a node labeled with `accelerator=nvidia-tesla-p100`, and includes tolerations to allow the pods to be scheduled on a node tainted with the key `tier`, value `frontend`, and effect `NoSchedule`.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl describe deploy nginx # you'll see the name of the replica set on the Events section and in the 'NewReplicaSet' property\n# OR you can find rs directly by:\nkubectl get rs -l run=nginx # if you created deployment by 'run' command\nkubectl get rs -l app=nginx # if you created deployment by 'create' command\n# you could also just do kubectl get rs\nkubectl get rs nginx-7bf7478b77 -o yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::19",
    "prompt": "Get the YAML for one of the pods created by the deployment called nginx, which uses the image nginx:1.18.0, with 2 replicas, and defines port 80 as the port that the container exposes. This deployment also includes a nodeSelector to place pods on a node labeled with `accelerator=nvidia-tesla-p100` and includes tolerations to allow the pods to be scheduled on a node tainted with the key `tier`, value `frontend`, and effect `NoSchedule`.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get po # get all the pods\n# OR you can find pods directly by:\nkubectl get po -l run=nginx # if you created deployment by 'run' command\nkubectl get po -l app=nginx # if you created deployment by 'create' command\nkubectl get po nginx-7bf7478b77-gjzp8 -o yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::20",
    "prompt": "Check how the deployment rollout is going for the nginx deployment, which uses the image nginx:1.18.0, has 2 replicas, and defines port 80 as the container's exposed port, including a nodeSelector for nodes labeled with `accelerator=nvidia-tesla-p100` and tolerations for nodes tainted with `tier=frontend` and effect `NoSchedule`.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout status deploy nginx",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::21",
    "prompt": "Update the nginx deployment, which uses the image nginx:1.18.0, has 2 replicas, and defines port 80 as the container's exposed port, with a nodeSelector for nodes labeled `accelerator=nvidia-tesla-p100` and tolerations for nodes tainted `tier=frontend` and effect `NoSchedule`, to use the nginx image version nginx:1.19.8.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl set image deploy nginx nginx=nginx:1.19.8\n# alternatively...\nkubectl edit deploy nginx # change the .spec.template.spec.containers[0].image",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::22",
    "prompt": "After updating the nginx deployment to use the nginx image version nginx:1.19.8, check the rollout history of this deployment and confirm that the replicas are OK.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout history deploy nginx\nkubectl get deploy nginx\nkubectl get rs # check that a new replica set has been created\nkubectl get po",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::23",
    "prompt": "Undo the latest update to the nginx deployment, where the deployment was updated to use nginx image version nginx:1.19.8, and verify that new pods are using the previous image version, which is nginx:1.18.0.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout undo deploy nginx\n# wait a bit\nkubectl get po # select one 'Running' Pod\nkubectl describe po nginx-5ff4457d65-nslcl | grep -i image # should be nginx:1.18.0",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::24",
    "prompt": "Update the previously mentioned nginx deployment by intentionally using an incorrect image version, specifically nginx:1.91, and verify that the deployment reflects this update.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl set image deploy nginx nginx=nginx:1.91\n# or\nkubectl edit deploy nginx\n# change the image to nginx:1.91\n# vim tip: type (without quotes) '/image' and press Enter, to navigate quickly",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::25",
    "prompt": "Verify that something's wrong with the rollout after intentionally updating an nginx deployment with an incorrect image version, specifically nginx:1.91.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout status deploy nginx\n# or\nkubectl get po # you'll see 'ErrImagePull' or 'ImagePullBackOff'",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::26",
    "prompt": "After intentionally updating an nginx deployment with an incorrect image version, specifically nginx:1.91, and verifying something is wrong with the rollout, return the deployment to the second revision (number 2) and verify the image is nginx:1.19.8.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout undo deploy nginx --to-revision=2\nkubectl describe deploy nginx | grep Image:\nkubectl rollout status deploy nginx # Everything should be OK",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::27",
    "prompt": "Assuming you have previously updated an nginx deployment multiple times, including intentionally updating it with an incorrect image version and then correcting it, now check the details of the fourth revision (number 4) of this nginx deployment.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout history deploy nginx --revision=4 # You'll also see the wrong image displayed here",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::28",
    "prompt": "Scale the nginx deployment, which you previously updated multiple times including intentionally updating it with an incorrect image version and then correcting it, to 5 replicas.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl scale deploy nginx --replicas=5\nkubectl get po\nkubectl describe deploy nginx",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::29",
    "prompt": "Autoscale the nginx deployment you previously updated multiple times, including intentionally updating it with an incorrect image version and then correcting it, setting the number of replicas to automatically adjust between 5 and 10, targeting CPU utilization at 80%",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl autoscale deploy nginx --min=5 --max=10 --cpu-percent=80\n# view the horizontalpodautoscalers.autoscaling for nginx\nkubectl get hpa nginx",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::30",
    "prompt": "Pause the rollout of the nginx deployment you previously autoscaled, including during the process of intentionally updating it with an incorrect image version and then correcting it, specifying that the number of replicas should automatically adjust between 5 and 10, targeting CPU utilization at 80%.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout pause deploy nginx",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::31",
    "prompt": "After pausing the rollout of the nginx deployment, which you previously autoscaled to automatically adjust the number of replicas between 5 and 10 based on a target CPU utilization of 80%, update the image to nginx:1.19.9 and verify that the rollout is indeed paused with no updates occurring.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl set image deploy nginx nginx=nginx:1.19.9\n# or\nkubectl edit deploy nginx\n# change the image to nginx:1.19.9\nkubectl rollout history deploy nginx # no new revision",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::32",
    "prompt": "After pausing the rollout of an nginx deployment that was previously autoscaled to automatically adjust the number of replicas between 5 and 10 based on a target CPU utilization of 80%, and updating the image to nginx:1.19.9 while verifying that the rollout is paused with no updates occurring, resume the rollout and check that the nginx:1.19.9 image has been applied.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl rollout resume deploy nginx\nkubectl rollout history deploy nginx\nkubectl rollout history deploy nginx --revision=6 # insert the number of your latest revision",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::33",
    "prompt": "Delete the nginx deployment that was paused during the rollout to update the image to nginx:1.19.9, and also delete the associated horizontal pod autoscaler that was configured to automatically adjust the number of replicas between 5 and 10 based on a target CPU utilization of 80%.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl delete deploy nginx\nkubectl delete hpa nginx\n\n#Or\nkubectl delete deploy/nginx hpa/nginx",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::34",
    "prompt": "After deleting the nginx deployment that was paused during the rollout to update the image to nginx:1.19.9, along with its associated horizontal pod autoscaler configured to automatically adjust the number of replicas between 5 and 10 based on a target CPU utilization of 80%, implement canary deployment by running two instances of nginx marked as version=v1 and version=v2 so that the load is balanced at a 75%-25% ratio.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-app-v1\n  labels:\n    app: my-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: my-app\n      version: v1\n  template:\n    metadata:\n      labels:\n        app: my-app\n        version: v1\n    spec:\n      containers:\n      - name: nginx\n        image: nginx\n        ports:\n        - containerPort: 80\n        volumeMounts:\n        - name: workdir\n          mountPath: /usr/share/nginx/html\n      initContainers:\n      - name: install\n        image: busybox:1.28\n        command:\n        - /bin/sh\n        - -c\n        - \"echo version-1 > /work-dir/index.html\"\n        volumeMounts:\n        - name: workdir\n          mountPath: \"/work-dir\"\n      volumes:\n      - name: workdir\n        emptyDir: {}",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::35",
    "prompt": "After implementing a canary deployment by running two instances of nginx marked as version=v1 and version=v2 with the load balanced at a 75%-25% ratio, following the deletion of the nginx deployment that was paused during the rollout to update its image to nginx:1.19.9 (along with its associated horizontal pod autoscaler configured to automatically adjust the number of replicas between 5 and 10 based on a target CPU utilization of 80%), now create a job named pi using the image perl:5.34. This job should execute the command with arguments \"perl -Mbignum=bpi -wle 'print bpi(2000)'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create job pi  --image=perl:5.34 -- perl -Mbignum=bpi -wle 'print bpi(2000)'",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::36",
    "prompt": "After the canary deployment process involving two nginx instances with versions v1 and v2 and the deletion of the nginx deployment updated to image nginx:1.19.9, and after creating a job named pi using the image perl:5.34 to execute the command \"perl -Mbignum=bpi -wle 'print bpi(2000)'\", wait until this job completes and then retrieve its output.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get jobs -w # wait till 'SUCCESSFUL' is 1 (will take some time, perl image might be big)\nkubectl get po # get the pod name\nkubectl logs pi-**** # get the pi numbers\nkubectl delete job pi",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::37",
    "prompt": "Following the completion of tasks related to a canary deployment process involving nginx instances with versions v1 and v2, the deletion of the nginx deployment updated to image nginx:1.19.9, and the creation and completion of a job named pi using the image perl:5.34 to execute the command \"perl -Mbignum=bpi -wle 'print bpi(2000)'\" to retrieve its output, create a job using the image busybox that executes the command 'echo hello;sleep 30;echo world'.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create job busybox --image=busybox -- /bin/sh -c 'echo hello;sleep 30;echo world'",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::38",
    "prompt": "After creating a job using the image busybox that executes the command 'echo hello;sleep 30;echo world' in the context of completing tasks for a canary deployment involving nginx instances and other specific Kubernetes operations, follow the logs for the pod, noting that you'll wait for 30 seconds.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get po # find the job pod\nkubectl logs busybox-ptx58 -f # follow the logs",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::39",
    "prompt": "After creating a job in Kubernetes using the image busybox with the command 'echo hello;sleep 30;echo world' in the context of a canary deployment operation involving nginx instances, check the status of this job, describe it, and view the logs of the pod generated by this job.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get jobs\nkubectl describe jobs busybox\nkubectl logs job/busybox",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::40",
    "prompt": "Delete the job created in Kubernetes that uses the image busybox with the command 'echo hello;sleep 30;echo world' in the context of a canary deployment operation involving nginx instances.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl delete job busybox",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::41",
    "prompt": "Create a job in Kubernetes that uses the image busybox with the command 'echo hello;sleep 30;echo world', in the context of a canary deployment operation involving nginx instances. Configure the job to run 5 times, one after the other. After completion, verify the job's status and then delete it.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create job busybox --image=busybox --dry-run=client -o yaml -- /bin/sh -c 'echo hello;sleep 30;echo world' > job.yaml\nvi job.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::42",
    "prompt": "Create a job in Kubernetes that uses the image busybox with the command 'echo hello;sleep 30;echo world', in the context of a canary deployment operation involving nginx instances. This time, configure the job to run 5 parallel instances. After completion, verify the job's status and then delete it.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "vi job.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::43",
    "prompt": "Create a job in Kubernetes using the image busybox with the command 'echo hello; sleep 30; echo world', similar to the context of a canary deployment operation involving nginx instances, but this time ensure that it will be automatically terminated by Kubernetes if it takes more than 30 seconds to execute. Configure the job to run 5 parallel instances as before.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create job busybox --image=busybox --dry-run=client -o yaml -- /bin/sh -c 'while true; do echo hello; sleep 10;done' > job.yaml\nvi job.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::44",
    "prompt": "Create a cron job in Kubernetes using the image busybox that runs on a schedule of \"*/1 * * * *\" and writes 'date; echo Hello from the Kubernetes cluster' to standard output, following the context of configuring Kubernetes jobs to perform specific tasks, similar to how you configured a job with parallel instances and automatic termination.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create cronjob busybox --image=busybox --schedule=\"*/1 * * * *\" -- /bin/sh -c 'date; echo Hello from the Kubernetes cluster'",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::45",
    "prompt": "View the logs of the cron job you created in Kubernetes with the busybox image, running on a schedule of \"*/1 * * * *\" and writing 'date; echo Hello from the Kubernetes cluster' to standard output, and then delete it.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get po # copy the ID of the pod whose container was just created\nkubectl logs <busybox-***> # you will see the date and message \nkubectl delete cj busybox # cj stands for cronjob",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::46",
    "prompt": "Create a cron job in Kubernetes using the busybox image, with the schedule \"*/1 * * * *\", that writes 'date; echo Hello from the Kubernetes cluster' to standard output. Watch the cron job's status until it runs. After it has run, check which job was executed by this cron job, view its log, and then delete the cron job.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get cj\nkubectl get jobs --watch\nkubectl get po --show-labels # observe that the pods have a label that mentions their 'parent' job\nkubectl logs busybox-1529745840-m867r\n# Bear in mind that Kubernetes will run a new job/pod for each new cron job\nkubectl delete cj busybox",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::47",
    "prompt": "Create a cron job in Kubernetes using the busybox image, with the schedule \"*/1 * * * *\" (which means it runs every minute), that writes 'date; echo Hello from the Kubernetes cluster' to standard output. Ensure the cron job is configured to be terminated if it takes more than 17 seconds to start execution after its scheduled time, indicating that the job has missed its scheduled time to run.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create cronjob time-limited-job --image=busybox --restart=Never --dry-run=client --schedule=\"* * * * *\" -o yaml -- /bin/sh -c 'date; echo Hello from the Kubernetes cluster' > time-limited-job.yaml\nvi time-limited-job.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::48",
    "prompt": "Create a cron job in Kubernetes using the busybox image, with the schedule \"*/1 * * * *\" (which means it runs every minute), that writes 'date; echo Hello from the Kubernetes cluster' to standard output. This cron job should not only be configured to be terminated if it takes more than 17 seconds to start execution after its scheduled time but should also be terminated if it successfully starts and takes more than 12 seconds to complete execution.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create cronjob time-limited-job --image=busybox --restart=Never --dry-run=client --schedule=\"* * * * *\" -o yaml -- /bin/sh -c 'date; echo Hello from the Kubernetes cluster' > time-limited-job.yaml\nvi time-limited-job.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "c.pod_design::49",
    "prompt": "Create a Kubernetes job based on a cron job that uses the busybox image, with the schedule \"*/1 * * * *\" (which means it runs every minute), to write 'date; echo Hello from the Kubernetes cluster' to standard output. This cron job is configured to be terminated if it takes more than 17 seconds to start execution after its scheduled time and also terminated if it successfully starts but takes more than 12 seconds to complete execution.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create job --from=cronjob/sample-cron-job sample-job",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "f.services::0",
    "prompt": "Create a pod with image nginx called nginx and expose its port 80",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx --restart=Never --port=80 --expose\n# observe that a pod as well as a service are created",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "f.services::1",
    "prompt": "After creating a pod with the image nginx called nginx and exposing its port 80, confirm that a ClusterIP has been created for it. Also, check the endpoints associated with this configuration.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get svc nginx # services\nkubectl get ep # endpoints",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "f.services::2",
    "prompt": "Retrieve the ClusterIP of the service created for a pod using the nginx image and exposed on port 80, then create a temporary busybox pod and use wget to 'hit' the retrieved ClusterIP.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get svc nginx # get the IP (something like 10.108.93.130)\nkubectl run busybox --rm --image=busybox -it --restart=Never --\nwget -O- [PUT THE POD'S IP ADDRESS HERE]:80\nexit",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "f.services::3",
    "prompt": "Convert the ClusterIP service, which was created for a pod using the nginx image and exposed on port 80, to a NodePort service and find the NodePort port number. Then, use the Node's IP address to access the service. Finally, delete both the service and the pod.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl edit svc nginx",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "f.services::4",
    "prompt": "Create a deployment called foo using the image 'dgkanatsios/simpleapp', which is a simple server that returns the hostname, and ensure this deployment has 3 replicas. Apply the label 'app=foo' to the deployment. Configure the deployment so that the containers within the pods will accept traffic on port 8080. This task follows the previous exercise where you converted a ClusterIP service for a pod running the nginx image and exposed on port 80 to a NodePort service, accessed it using the Node's IP address, and then deleted both the service and the pod. For this new task, do NOT create a service for the deployment yet.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create deploy foo --image=dgkanatsios/simpleapp --port=8080 --replicas=3\nkubectl label deployment foo --overwrite app=foo #This is optional since kubectl create deploy foo will create label app=foo by default",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "f.services::5",
    "prompt": "After creating a deployment called foo with the image 'dgkanatsios/simpleapp', which has 3 replicas and is configured to accept traffic on port 8080, get the pod IPs. Then, create a temporary busybox pod and try hitting the foo deployment pod IPs on port 8080.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get pods -l app=foo -o wide # 'wide' will show pod IPs\nkubectl run busybox --image=busybox --restart=Never -it --rm -- sh\nwget -O- <POD_IP>:8080 # do not try with pod name, will not work\n# try hitting all IPs generated after running 1st command to confirm that hostname is different\nexit\n# or\nkubectl get po -o wide -l app=foo | awk '{print $6}' | grep -v IP | xargs -L1 -I '{}' kubectl run --rm -ti tmp --restart=Never --image=busybox -- wget -O- http://\\{\\}:8080\n# or\nkubectl get po -l app=foo -o jsonpath='{range .items[*]}{.status.podIP}{\"\\n\"}{end}' | xargs -L1 -I '{}' kubectl run --rm -ti tmp --restart=Never --image=busybox -- wget -O- http://\\{\\}:8080",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "f.services::6",
    "prompt": "Create a service that exposes the deployment called foo, which uses the image 'dgkanatsios/simpleapp', has 3 replicas, and is configured to accept traffic on port 8080, on a new port 6262. Verify the service's existence and check the endpoints.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl expose deploy foo --port=6262 --target-port=8080\nkubectl get service foo # you will see ClusterIP as well as port 6262\nkubectl get endpoints foo # you will see the IPs of the three replica pods, listening on port 8080",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "f.services::7",
    "prompt": "Create a temporary busybox pod and use wget to connect to the service named 'foo', which exposes a deployment called foo using the image 'dgkanatsios/simpleapp', with 3 replicas, configured to accept traffic on port 8080, and is exposed on a new port 6262. Verify that each time there's a different hostname returned to demonstrate load balancing between the replicas. After testing, delete the deployment named foo and its associated services to clean up the cluster.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get svc # get the foo service ClusterIP\nkubectl run busybox --image=busybox -it --rm --restart=Never -- sh\nwget -O- foo:6262 # DNS works! run it many times, you'll see different pods responding\nwget -O- <SERVICE_CLUSTER_IP>:6262 # ClusterIP works as well\n# you can also kubectl logs on deployment pods to see the container logs\nkubectl delete svc foo\nkubectl delete deploy foo",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "f.services::8",
    "prompt": "After creating a temporary busybox pod to connect to a previously mentioned service named 'foo' that exposes a deployment with 3 replicas, using the image 'dgkanatsios/simpleapp', and verifying load balancing by observing different hostnames, proceed to the next task. Create an nginx deployment of 2 replicas and expose it via a ClusterIP service on port 80. Then, create a NetworkPolicy that allows only pods labeled with 'access: granted' to access the nginx deployment's pods. Apply this policy to enforce the specified access control.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create deployment nginx --image=nginx --replicas=2\nkubectl expose deployment nginx --port=80\n\nkubectl describe svc nginx # see the 'app=nginx' selector for the pods\n# or\nkubectl get svc nginx -o yaml\n\nvi policy.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "j.podman::0",
    "prompt": "Create a Dockerfile to deploy an Apache HTTP Server which hosts a custom main page",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "FROM docker.io/httpd:2.4\nRUN echo \"Hello, World!\" > /usr/local/apache2/htdocs/index.html",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "j.podman::1",
    "prompt": "Build the Dockerfile designed to deploy an Apache HTTP Server with a custom main page and determine how many layers the resulting image consists of.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":~$ podman build -t simpleapp .\nSTEP 1/2: FROM httpd:2.4\nSTEP 2/2: RUN echo \"Hello, World!\" > /usr/local/apache2/htdocs/index.html\nCOMMIT simpleapp\n--> ef4b14a72d0\nSuccessfully tagged localhost/simpleapp:latest\nef4b14a72d02ae0577eb0632d084c057777725c279e12ccf5b0c6e4ff5fd598b\n\n:~$ podman images\nREPOSITORY               TAG         IMAGE ID      CREATED        SIZE\nlocalhost/simpleapp      latest      ef4b14a72d02  8 seconds ago  148 MB\ndocker.io/library/httpd  2.4         98f93cd0ec3b  7 days ago     148 MB\n\n:~$ podman image tree localhost/simpleapp:latest\nImage ID: ef4b14a72d02\nTags:     [localhost/simpleapp:latest]\nSize:     147.8MB\nImage Layers\n├── ID: ad6562704f37 Size:  83.9MB\n├── ID: c234616e1912 Size: 3.072kB\n├── ID: c23a797b2d04 Size: 2.721MB\n├── ID: ede2e092faf0 Size: 61.11MB\n├── ID: 971c2cdf3872 Size: 3.584kB Top Layer of: [docker.io/library/httpd:2.4]\n└── ID: 61644e82ef1f Size: 6.144kB Top Layer of: [localhost/simpleapp:latest]",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "j.podman::2",
    "prompt": "Run the Docker image of the Apache HTTP Server with a custom main page locally, inspect its status and logs, and finally test that it responds as expected.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":~$ podman run -d --name test -p 8080:80 localhost/simpleapp\n2f3d7d613ea6ba19703811d30704d4025123c7302ff6fa295affc9bd30e532f8\n\n:~$ podman ps\nCONTAINER ID  IMAGE                       COMMAND           CREATED        STATUS            PORTS                 NAMES\n2f3d7d613ea6  localhost/simpleapp:latest  httpd-foreground  5 seconds ago  Up 6 seconds ago  0.0.0.0:8080->80/tcp  test\n\n:~$ podman logs test\nAH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 10.0.2.100. Set the 'ServerName' directive globally to suppress this message\nAH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 10.0.2.100. Set the 'ServerName' directive globally to suppress this message\n[Sat Jun 04 16:15:38.071377 2022] [mpm_event:notice] [pid 1:tid 139756978220352] AH00489: Apache/2.4.53 (Unix) configured -- resuming normal operations\n[Sat Jun 04 16:15:38.073570 2022] [core:notice] [pid 1:tid 139756978220352] AH00094: Command line: 'httpd -D FOREGROUND'\n\n:~$ curl 0.0.0.0:8080\nHello, World!",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "j.podman::3",
    "prompt": "After running the Docker image of the Apache HTTP Server with a custom main page locally, inspecting its status and logs, and finally testing that it responds as expected, run a command inside the pod to print out the index.html file.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":~$ podman exec -it test cat /usr/local/apache2/htdocs/index.html\nHello, World!",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "j.podman::4",
    "prompt": "After successfully running the Docker image of the Apache HTTP Server with a custom main page locally, inspecting its status and logs, and verifying that it responds as expected by running a command inside the pod to print out the index.html file, tag the same image with the IP address and port of a private local registry and then push the image to this registry.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":~$ podman tag localhost/simpleapp $registry_ip:5000/simpleapp\n\n:~$ podman push $registry_ip:5000/simpleapp",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "j.podman::5",
    "prompt": "After successfully tagging and pushing the Docker image of the Apache HTTP Server to a private local registry as previously outlined, create a container from this image without running/starting it.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":~$ podman create busybox # create\nResolved \"busybox\" as an alias (/etc/containers/registries.conf.d/000-shortnames.conf)\nTrying to pull docker.io/library/busybox:latest...\nGetting image source signatures\nCopying blob sha256:213a27df5921cd9ae24732504c590bb6408911c20fb50a597f2a40896d554a8f\nCopying config sha256:3fba0c87fcc8ba126bf99e4ee205b43c91ffc6b15bb052315312e71bc6296551\nWriting manifest to image destination\n51b613406e8889213c176523e1c430e4bd00047965b0c22cff5b1c9badfbc452\n\n:~$ podman container ls -a\nCONTAINER ID  IMAGE                             COMMAND     CREATED        STATUS      PORTS       NAMES\n51b613406e88  docker.io/library/busybox:latest  sh          2 minutes ago  Created                 adoring_almeida",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "j.podman::6",
    "prompt": "Export the container created from the Docker image of the Apache HTTP Server that was tagged and pushed to a private local registry, without starting it, to an output.tar file.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":~$ podman container ls -a # pick the container id\nCONTAINER ID  IMAGE                             COMMAND     CREATED        STATUS      PORTS       NAMES\n51b613406e88  docker.io/library/busybox:latest  sh          2 minutes ago  Created                 adoring_almeida\n\n:~$ podman export <container id> --output=output.tar\n\n:~$ ls -al output.tar\n-rw-r--r--@ 1 limistah  wheel  4272640 28 Aug 13:48 output.tar",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "j.podman::7",
    "prompt": "Run a pod with the Apache HTTP Server image that was previously tagged and pushed to a private local registry.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":~$ kubectl run simpleapp --image=$registry_ip:5000/simpleapp --port=80\n\n:~$ curl ${kubectl get pods simpleapp -o jsonpath='{.status.podIP}'}\nHello, World!",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "j.podman::8",
    "prompt": "After running a pod with the Apache HTTP Server image from a private local registry, log into a remote registry server and then read the credentials from the default file.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":~$ podman login --username $YOUR_USER --password $YOUR_PWD docker.io\n:~$ cat ${XDG_RUNTIME_DIR}/containers/auth.json\n{\n        \"auths\": {\n                \"docker.io\": {\n                        \"auth\": \"Z2l1bGl0JLSGtvbkxCcX1xb617251xh0x3zaUd4QW45Q3JuV3RDOTc=\"\n                }\n        }\n}",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "j.podman::9",
    "prompt": "Create a Kubernetes secret to store the login credentials for a remote registry server, after logging in to access an Apache HTTP Server image from a private local registry, using both the credentials retrieved from the default file and directly from the command line interface (CLI).",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":~$ kubectl create secret generic mysecret --from-file=.dockerconfigjson=${XDG_RUNTIME_DIR}/containers/auth.json --type=kubernetes.io/dockeconfigjson\nsecret/mysecret created\n:~$ kubectl create secret docker-registry mysecret2 --docker-server=https://index.docker.io/v1/ --docker-username=$YOUR_USR --docker-password=$YOUR_PWD\nsecret/mysecret2 created",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "j.podman::10",
    "prompt": "Create the manifest for a Pod that uses one of the two secrets created for storing login credentials for a remote registry server, to pull an Apache HTTP Server image hosted on the same private local registry, where the secrets were either retrieved from the default file or directly from the command line interface (CLI).",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: private-reg\nspec:\n  containers:\n  - name: private-reg-container\n    image: $YOUR_PRIVATE_IMAGE\n  imagePullSecrets:\n  - name: mysecret",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "j.podman::11",
    "prompt": "Following the creation of a Pod manifest that utilizes one of the two secrets for storing login credentials to pull an Apache HTTP Server image from a private local registry, describe the process for cleaning up all the images and containers associated with this setup.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": ":~$ podman rm --all --force\n:~$ podman rmi --all\n:~$ kubectl delete pod simpleapp",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::0",
    "prompt": "Create a configmap named config with values foo=lala,foo2=lolo",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create configmap config --from-literal=foo=lala --from-literal=foo2=lolo",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::1",
    "prompt": "Display the values of the configmap named config with values foo=lala,foo2=lolo.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get cm config -o yaml\n# or\nkubectl describe cm config",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::2",
    "prompt": "Create and display a configmap from a file, following the example where the values of a configmap named config with values foo=lala,foo2=lolo were displayed.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "echo -e \"foo3=lili\\nfoo4=lele\" > config.txt",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::3",
    "prompt": "Create and display a configmap from a .env file, similar to the previous exercise where a configmap named config with values foo=lala,foo2=lolo was created and displayed.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "echo -e \"var1=val1\\n# this is a comment\\n\\nvar2=val2\\n#anothercomment\" > config.env",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::4",
    "prompt": "Create and display a configmap from a file, similar to the previous exercise where a configmap named config with values foo=lala,foo2=lolo was created and displayed, giving the key 'special'.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "echo -e \"var3=val3\\nvar4=val4\" > config4.txt",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::5",
    "prompt": "Create a configMap named 'options' with the value var5=val5, similar to the exercise where a configmap named config with values foo=lala,foo2=lolo was created. Then, create a new nginx pod that loads the value from variable 'var5' into an environment variable named 'option'.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create cm options --from-literal=var5=val5\nkubectl run nginx --image=nginx --restart=Never --dry-run=client -o yaml > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::6",
    "prompt": "Create a configMap named 'anotherone' with the values 'var6=val6' and 'var7=val7', similar to the previous task where you created a configMap named 'options' with the value 'var5=val5'. Then, create a new nginx pod that loads the values from 'var6' and 'var7' into environment variables, resembling the method used to load 'var5' into the 'option' environment variable in the nginx pod you previously set up.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create configmap anotherone --from-literal=var6=val6 --from-literal=var7=val7\nkubectl run --restart=Never nginx --image=nginx -o yaml --dry-run=client > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::7",
    "prompt": "Create a configMap named 'cmvolume' with the values 'var8=val8' and 'var9=val9'. Then create a new nginx pod that loads this configMap as a volume, similarly to how you created a new nginx pod that loaded values from a configMap into environment variables in a previous task. Mount the 'cmvolume' configMap at the path '/etc/lala' inside the nginx pod. After the pod is running, use the 'ls' command to list the contents of the '/etc/lala' directory to verify the configMap's values were correctly loaded.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create configmap cmvolume --from-literal=var8=val8 --from-literal=var9=val9\nkubectl run nginx --image=nginx --restart=Never -o yaml --dry-run=client > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::8",
    "prompt": "Create the YAML for an nginx pod that runs with the user ID 101, ensuring it follows the practice of loading a configMap named 'cmvolume' with the values 'var8=val8' and 'var9=val9' as a volume. The configMap should be mounted at the path '/etc/lala' inside the nginx pod as demonstrated in a related task. No need to create the pod.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx --restart=Never --dry-run=client -o yaml > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::9",
    "prompt": "Create the YAML for an nginx pod that runs with the user ID 101, ensures it follows the practice of loading a configMap named 'cmvolume' with the values 'var8=val8' and 'var9=val9' as a volume, which should be mounted at the path '/etc/lala' inside the nginx pod, and has the capabilities \"NET_ADMIN\", \"SYS_TIME\" added to its single container.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx --restart=Never --dry-run=client -o yaml > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::10",
    "prompt": "Create the YAML for an nginx pod that runs with the user ID 101, ensures it loads a configMap named 'cmvolume' with the values 'var8=val8' and 'var9=val9' as a volume mounted at '/etc/lala', has the capabilities \"NET_ADMIN\", \"SYS_TIME\" in its single container, and specifies resource requests of cpu=100m, memory=256Mi along with limits of cpu=200m, memory=512Mi.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx --dry-run=client -o yaml > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::11",
    "prompt": "Create a namespace named limitrange and within it, define a LimitRange that sets the maximum memory limit for pods at 500Mi and the minimum at 100Mi, ensuring it accommodates the specifications of a pod like the nginx pod from the previous context which includes resource requests and limits.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create ns limitrange",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::12",
    "prompt": "Describe the characteristics and purpose of the namespace named limitrange where you have defined a LimitRange setting the maximum memory limit for pods at 500Mi and the minimum at 100Mi.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl describe limitrange ns-memory-limit -n limitrange",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::13",
    "prompt": "Create an nginx pod that requests 250Mi of memory in the namespace named limitrange, where a LimitRange has been defined setting the maximum memory limit for pods at 500Mi and the minimum at 100Mi.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "apiVersion: v1\nkind: Pod\nmetadata:\n  creationTimestamp: null\n  labels:\n    run: nginx\n  name: nginx\n  namespace: limitrange\nspec:\n  containers:\n  - image: nginx\n    name: nginx\n    resources:\n      requests:\n        memory: \"250Mi\"\n      limits:\n        memory: \"500Mi\" # limit has to be specified and be <= limitrange\n  dnsPolicy: ClusterFirst\n  restartPolicy: Always\nstatus: {}",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::14",
    "prompt": "Create a ResourceQuota in the namespace `one` specifying hard requests for `cpu=1` and `memory=1Gi`, and hard limits for `cpu=2` and `memory=2Gi`. This is in the context of managing Kubernetes resources where, previously, you were asked to create an nginx pod requesting 250Mi of memory in a namespace called limitrange, which had a LimitRange set with a maximum memory limit of 500Mi for pods and a minimum of 100Mi.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create ns one",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::15",
    "prompt": "After having created a ResourceQuota in the namespace `one` specifying hard requests for `cpu=1` and `memory=1Gi`, as well as hard limits for `cpu=2` and `memory=2Gi`, attempt to create a pod within the same namespace with resource requests `cpu=2`, `memory=3Gi` and limits `cpu=3`, `memory=4Gi`.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "vi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::16",
    "prompt": "Given a ResourceQuota in namespace `one` specifying hard requests for `cpu=1` and `memory=1Gi`, as well as hard limits for `cpu=2` and `memory=2Gi`, create a pod within the same namespace with resource requests `cpu=0.5`, `memory=1Gi` and limits `cpu=1`, `memory=2Gi`.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "vi pod2.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::17",
    "prompt": "Create a secret called mysecret with the values password=mypass in the namespace 'one'.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create secret generic mysecret --from-literal=password=mypass",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::18",
    "prompt": "Create a secret called mysecret2 in the same Kubernetes namespace as the previous secret ('one') that gets key/value pairs from a file.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "echo -n admin > username",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::19",
    "prompt": "Retrieve the value of the secret named 'mysecret2', which was created in the same Kubernetes namespace as the secret named 'one', using key/value pairs sourced from a file.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get secret mysecret2 -o yaml\necho -n YWRtaW4= | base64 -d # on MAC it is -D, which decodes the value and shows 'admin'",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::20",
    "prompt": "Create an nginx pod that mounts the secret named 'mysecret2', which was created in the same Kubernetes namespace as the secret named 'one' using key/value pairs sourced from a file, in a volume on path /etc/foo.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx --restart=Never -o yaml --dry-run=client > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::21",
    "prompt": "Delete the nginx pod that mounts the secret named 'mysecret2', previously created in the same Kubernetes namespace as the secret named 'one' using key/value pairs sourced from a file, in a volume on path /etc/foo. Then, mount the variable 'username' from secret 'mysecret2' onto a new nginx pod in an environment variable called 'USERNAME'.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl delete po nginx\nkubectl run nginx --image=nginx --restart=Never -o yaml --dry-run=client > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::22",
    "prompt": "Create a Secret named 'ext-service-secret' in the namespace 'secret-ops', separate from the namespace involving 'mysecret2' and the nginx pod operation. Then, provide the key-value pair API_KEY=LmLHbYhsgWZwNifiqaRorH8T as a literal to the secret.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "export ns=\"-n secret-ops\"\nexport do=\"--dry-run=client -oyaml\"\nk create secret generic ext-service-secret --from-literal=API_KEY=LmLHbYhsgWZwNifiqaRorH8T $ns $do > sc.yaml\nk apply -f sc.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::23",
    "prompt": "Create a Pod named 'consumer' with the image 'nginx' in the namespace 'secret-ops' where you have previously created a Secret named 'ext-service-secret' containing the key-value pair API_KEY=LmLHbYhsgWZwNifiqaRorH8T. Ensure this Secret is consumed as an environment variable by the Pod. Then, open an interactive shell to the Pod, and print all environment variables to confirm the Secret's consumption.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "export ns=\"-n secret-ops\"\nexport do=\"--dry-run=client -oyaml\"\nk run consumer --image=nginx $ns $do > nginx.yaml\nvi nginx.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::24",
    "prompt": "After successfully creating a Pod named 'consumer' with the image 'nginx' in the namespace 'secret-ops', where you created a Secret named 'ext-service-secret' containing the key-value pair API_KEY=LmLHbYhsgWZwNifiqaRorH8T and ensured this Secret is consumed as an environment variable by the Pod, proceed to create a new Secret named 'my-secret' of type 'kubernetes.io/ssh-auth' in the same namespace 'secret-ops'. For this new Secret, define a single key named 'ssh-privatekey', and ensure it is pointing to the file 'id_rsa' found in this directory.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "#Tips, export to variable\nexport do=\"--dry-run=client -oyaml\"\nexport ns=\"-n secret-ops\"\n\n#if id_rsa file didn't exist.\nssh-keygen\n\nk create secret generic my-secret $ns --type=\"kubernetes.io/ssh-auth\" --from-file=ssh-privatekey=id_rsa $do > sc.yaml\nk apply -f sc.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::25",
    "prompt": "Create a Pod named 'consumer' with the image 'nginx' in the namespace 'secret-ops', and consume the newly created 'my-secret' Secret, which is of type 'kubernetes.io/ssh-auth' containing a key 'ssh-privatekey' that points to the file 'id_rsa', as a Volume. Mount this Secret as a Volume to the path /var/app with read-only access. Open an interactive shell to the Pod, and render the contents of the file.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "#Tips, export to variable\nexport ns=\"-n secret-ops\"\nexport do=\"--dry-run=client -oyaml\"\nk run consumer --image=nginx $ns $do > nginx.yaml\nvi nginx.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::26",
    "prompt": "List all the service accounts in a Kubernetes cluster across all namespaces.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get sa --all-namespaces",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::27",
    "prompt": "Create a new service account called 'myuser' in a Kubernetes cluster.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create sa myuser",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::28",
    "prompt": "Create an nginx pod that uses a service account called 'myuser' in a Kubernetes cluster.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx --restart=Never -o yaml --dry-run=client > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "d.configuration::29",
    "prompt": "Generate an API token for the service account 'myuser' used by an nginx pod in a Kubernetes cluster.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl create token myuser",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "e.observability::0",
    "prompt": "Create an nginx pod with a liveness probe that just runs the command 'ls'. Save its YAML in pod.yaml. Run it, check its probe status, delete it.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx --restart=Never --dry-run=client -o yaml > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "e.observability::1",
    "prompt": "Modify the YAML configuration of an nginx pod that you previously created with a liveness probe running the command 'ls'. Adjust the liveness probe in the pod.yaml file to start after 5 seconds and set the interval between probes to 5 seconds. After making these adjustments, run the updated pod, check its liveness probe status to ensure it is working as expected, then delete the pod.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl explain pod.spec.containers.livenessProbe # get the exact names",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "e.observability::2",
    "prompt": "Create an nginx pod (that includes port 80) with an HTTP readinessProbe configured to check the path '/' on port 80. After creation, run this pod, verify the functionality of the readinessProbe by checking its status to ensure it is working as expected, then delete the pod. This question follows the previous task where you modified a YAML configuration for an nginx pod by adjusting a liveness probe; now you'll focus on implementing and testing a readinessProbe.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run nginx --image=nginx --dry-run=client -o yaml --restart=Never --port=80 > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "e.observability::3",
    "prompt": "Following the task where you created an nginx pod with a readinessProbe on port 80, now turn your attention to the broader cluster environment. Within the `qa`, `alan`, `test`, and `production` namespaces, all pods are configured with liveness probes. Please list all pods whose liveness probes have failed, providing the output in the format of `<namespace>/<pod name>` per line.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "LAST SEEN   TYPE      REASON      OBJECT              MESSAGE\n22m         Warning   Unhealthy   pod/liveness-exec   Liveness probe failed: cat: can't open '/tmp/healthy': No such file or directory",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "e.observability::4",
    "prompt": "Create a busybox pod in any namespace that runs the following command: `i=0; while true; do echo \"$i: $(date)\"; i=$((i+1)); sleep 1; done`. After deployment, check and provide its logs.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run busybox --image=busybox --restart=Never -- /bin/sh -c 'i=0; while true; do echo \"$i: $(date)\"; i=$((i+1)); sleep 1; done'\nkubectl logs busybox -f # follow the logs",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "e.observability::5",
    "prompt": "Create a busybox pod in any namespace that runs the command `ls /notexist`. Check the logs to determine if there's an error (there will be an error). After reviewing the error in the logs, delete the pod.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run busybox --restart=Never --image=busybox -- /bin/sh -c 'ls /notexist'\n# show that there's an error\nkubectl logs busybox\nkubectl describe po busybox\nkubectl delete po busybox",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "e.observability::6",
    "prompt": "Create a busybox pod in any namespace that runs the command `ls /notexist`, similar to a previous task. Check the pod's logs to determine if there's an error (as expected, there will be an error). After observing the error, delete the pod forcefully using a 0 grace period.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run busybox --restart=Never --image=busybox -- notexist\nkubectl logs busybox # will bring nothing! container never started\nkubectl describe po busybox # in the events section, you'll see the error\n# also...\nkubectl get events | grep -i error # you'll see the error here as well\nkubectl delete po busybox --force --grace-period=0",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "e.observability::7",
    "prompt": "Get CPU/memory utilization for nodes in the cluster (ensure that [metrics-server](https://github.com/kubernetes-incubator/metrics-server) is installed and running) after completing the task of creating a busybox pod in any namespace that runs the command `ls /notexist`, checking the pod's logs for an expected error, and forcefully deleting the pod with a 0 grace period.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl top nodes",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "h.helm::0",
    "prompt": "Creating a basic Helm chart",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "helm create chart-test ## this would create a helm",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "h.helm::1",
    "prompt": "What are the steps to deploy an application using a Helm chart, assuming you have already created a basic Helm chart?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "helm install -f myvalues.yaml myredis ./redis",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "h.helm::2",
    "prompt": "After deploying an application using a Helm chart, how can you find all pending Helm deployments across all namespaces?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "helm list --pending -A",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "h.helm::3",
    "prompt": "How can you uninstall a Helm release after identifying pending Helm deployments across all namespaces?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "helm uninstall -n namespace release_name",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "h.helm::4",
    "prompt": "What is the command to upgrade a Helm chart after uninstalling a Helm release, a process used for managing applications in Kubernetes?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "helm upgrade -f myvalues.yaml -f override.yaml redis ./redis",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "h.helm::5",
    "prompt": "What is the command to add or update a Helm chart repository before upgrading a Helm chart, a necessary step when managing applications in Kubernetes?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "helm repo add [NAME] [URL]  [flags]\n\nhelm repo list / helm repo ls\n\nhelm repo remove [REPO1] [flags]\n\nhelm repo update / helm repo up\n\nhelm repo update [REPO1] [flags]\n\nhelm repo index [DIR] [flags]",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "h.helm::6",
    "prompt": "What is the command to download a Helm chart from a repository after adding or updating the Helm chart repository, a step necessary when managing applications in Kubernetes?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "helm pull [chart URL | repo/chartname] [...] [flags] ## this would download a helm, not install \nhelm pull --untar [rep/chartname] # untar the chart after downloading it",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "h.helm::7",
    "prompt": "What is the command to add the Bitnami repo located at https://charts.bitnami.com/bitnami to Helm, a step necessary before downloading Helm charts from this repository when managing applications in Kubernetes?",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "helm repo add bitnami https://charts.bitnami.com/bitnami",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "h.helm::8",
    "prompt": "After adding the Bitnami repo to Helm, a necessary step before downloading Helm charts for managing applications in Kubernetes, write the contents of the values.yaml file of the `bitnami/node` chart to standard output.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "helm show values bitnami/node",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "h.helm::9",
    "prompt": "Install the `bitnami/node` chart using Helm, which is necessary for managing applications in Kubernetes after adding the Bitnami repo to Helm, setting the number of replicas to 5.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "helm show values bitnami/node | grep -i replica",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "i.crd::0",
    "prompt": "Create a CustomResourceDefinition manifest file for an Operator with the following specifications :",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "apiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  # name must match the spec fields below, and be in the form: <plural>.<group>\n  name: operators.stable.example.com\nspec:\n  group: stable.example.com\n  versions:\n    - name: v1\n      served: true\n      # One and only one version must be marked as the storage version.\n      storage: true\n      schema:\n        openAPIV3Schema:\n          type: object\n          properties:\n            spec:\n              type: object\n              properties:\n                email:\n                  type: string\n                name:\n                  type: string\n                age:\n                  type: integer\n  scope: Namespaced\n  names:\n    plural: operators\n    singular: operator\n    # kind is normally the CamelCased singular type. Your resource manifests use this.\n    kind: Operator\n    shortNames:\n    - op",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "i.crd::1",
    "prompt": "Create the CustomResourceDefinition (CRD) resource in the Kubernetes (K8S) API based on the manifest file for an Operator with the specified specifications.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl apply -f operator-crd.yml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "i.crd::2",
    "prompt": "Create a custom object from the CustomResourceDefinition (CRD) resource you previously created in the Kubernetes API for an Operator, based on the specified specifications in the manifest file.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "apiVersion: stable.example.com/v1\nkind: Operator\nmetadata:\n  name: operator-sample\nspec:\n  email: operator-sample@stable.example.com\n  name: \"operator sample\"\n  age: 30",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "i.crd::3",
    "prompt": "List the custom object you created from the CustomResourceDefinition (CRD) in the Kubernetes API for an Operator, as specified in the previous question's manifest file.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl get operators\nor\nkubectl get operator\nor\nkubectl get op",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "b.multi_container_pods::0",
    "prompt": "Create a Pod with two containers, both with image busybox and command \"echo hello; sleep 3600\". Connect to the second container and run 'ls'",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run busybox --image=busybox --restart=Never -o yaml --dry-run=client -- /bin/sh -c 'echo hello;sleep 3600' > pod.yaml\nvi pod.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  },
  {
    "id": "b.multi_container_pods::1",
    "prompt": "Create a pod with an nginx container exposed on port 80 and add a busybox init container that performs the command \"echo 'Test' > /work-dir/index.html\". To share data between the init container and the nginx container, use a volume of type emptyDir. Mount this volume at \"/work-dir\" in the init container and at \"/usr/share/nginx/html\" in the nginx container to replace the default nginx webpage. After setting up the pod, determine its IP address. Then, create a separate pod with a busybox container and execute the command \"wget -O- [IP of the first pod]\" to download and display the content served by the nginx container.",
    "type": "command",
    "pre_shell_cmds": [],
    "initial_files": {},
    "validation_steps": [
      {
        "cmd": "kubectl run box --image=nginx --restart=Never --port=80 --dry-run=client -o yaml > pod-init.yaml",
        "matcher": {}
      }
    ],
    "explanation": null,
    "categories": [],
    "difficulty": null,
    "metadata": {}
  }
]