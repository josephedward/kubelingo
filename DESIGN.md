Use these guidelines to generate questions that are easy to organize. Do NOT worry about difficulty level for now. Questions are questions - ideally we will want to be able to answer all of them we come across. Keep the CLI architecture simple. Lean on /docs to help you provide context. 

When the app starts, ask the user for AI provider: 

--- AI Provider ---
○ OpenAI
○ Gemini

Then prompt for an API key unless one has already been stored. Store API keys permanently once given. Test the API keys when provided and let the user know if they are ready to bill for tokens. Make it simple to add AI providers - we will likely be using more in the future. It seems like the easiest way to implement the AI-generation and feedback is with Simon Willison’s ‘llm’ project (and llm-gemini). Try to use those modules unless you can come up with a simpler architecture.  

Here is how the AI Provider submenu should look: 

 What would you like to do? (Use arrow keys) 
» ○ Set active AI Provider (current: Gemini) 
    --- API Keys --- 
    ○ View Gemini API Key (Set (from file)) 
    ○ Set/Update Gemini API Key 
    ○ View Openai API Key (Set (from env)) 
    ○ Set/Update Openai API Key 


Here is how we want the primary menu to look:  

   --- Learn ---
   ○ Socratic Mode (Socratic Tutor)
   ○ Missed Questions (2)
   --- Drill ---
   ○ Open Ended Questions (6)
   ○ Basic Terminology (205)
   ○ Command Syntax (105)
   ○ YAML Manifest (44)
   --- Settings ---
   ○ AI 
   ○ Clusters
   ○ Question Management
   ○ Help
   ○ Report Bug (bug ticket script)
   ○ Exit App

Since we are drilling Kubernetes for the CKAD, all of our questions will be in YAML. They will be stored in the /yaml dir. We will use a sqlite db to track all changes to the yaml. We will perform backups of the yaml regularly. We have consolidated lists of all questions in /yaml/backups. Here is our basic schema for the questions: 

Question Types: 
- Open-Ended: Require AI to do fuzzy matching on an explanation - these will be entirely produced by ‘Socratic Mode’ and require an active AI to evaluate if ‘more or less’ correct. The user should be able to navigate answers with arrows easily, not creating strange karat “^” type notations when attempting to edit their answer. The question should be graded as soon as the user hits enter on the command line. 
- Basic Terminology: Will be asking for a single command, resource type, short name, function, true/false - they are the only type can be evaluated without AI. But they will need to be generated by AI, and the app will need to be able to easily add additional ones via AI parsing. The question should be graded as soon as the user hits enter on the command line. The user should be able to navigate answers with arrows easily, not creating strange karat “^” type notations when attempting to edit their answer. 
- Command Syntax: these will need to be literally evaluated at the command line, and will require AI support, because there will be multiple ways of solving a problem, there will be shorthand, aliases, and duplicate-purpose commands that would viably solve the problem the same as an overly static string response. These should have suggested answers, but the AI needs to override if the user provides a correct answer that is not an exact replica of what is stated in the YAML. These will be focused on frequently seen commands in Linux, Vim, Kubectl, and Helm. The question should be graded as soon as the user hits enter on the command line. The user should be able to navigate answers with arrows easily, not creating strange karat “^” type notations when attempting to edit their answer. 
- YAML Manifest: these are going to be the most important part of this app. The declarative approach of applying manifests is really what kubernetes is all about, and the CKAD will depend on this heavily. This will require the user to create a manifest from scratch, or edit an existing yaml. This means that the app should start Vim for the user, displaying the prompt in the vim session with a created file, and then when the user quits Vim, that file should be graded for correctness. The user should not be expected run Vim in an actual CLI, as this will confuse the app and the user. 

Socratic Mode
Under Socratic Mode, there should be a submenu: 

--- Exercise Type ---
   ○ Open-Ended
   ○ Basic Terminology
   ○ Command Syntax
   ○ YAML Manifests

Then show them the subject matter submenu (shown below). Do not worry about level of difficulty for now. The level of difficulty largely depends on the exercise type. Remove that field(difficulty) from the schema.

Under question management, we need a new submenu. It will replace ‘Tool Scripts’ and will be orchestrated by the script kubelingo_tools.py or by the combined yaml and question manager scripts(we should combine them in scripts as they are similar; dont remove functions though). Edit /scripts as needed to handle and/or bring in modules y you need from the core app. Here is what the menu should look like:

--- Manage Questions ---
○ Generate Questions (generator)
○ Add Questions (using AI schema inference, rewriting and reformatting the given questions as needed)
○ Remove Questions
○ Triaged Questions (should list and allow for deletion or AI editing)

Don’t use the bit inside the parentheticals. Repurpose these as much as you need to make the rest of the app work. We should have what we need to help manage other aspects of the app. Feel free to totally delete them and start over if they are spaghetti/confusing. 


Our Subject Matter Categories will be subordinate to Question Type - that is, every single question type could have a question about ANY one of these subjects: 
- Linux Syntax(Commands from Bash, Vim, Kubectl, Docker, Helm)  
- Core workloads (Pods, ReplicaSets, Deployments; rollouts/rollbacks)
- Pod design patterns (initContainers, sidecars, lifecycle hooks)
- Commands, args, and env (ENTRYPOINT/CMD overrides, env/envFrom)
- App configuration (ConfigMaps, Secrets, projected & downwardAPI volumes)
- Probes & health (liveness, readiness, startup; graceful shutdown)
- Resource management (requests/limits, QoS classes, HPA basics)
- Jobs & CronJobs (completions, parallelism, backoff, schedules)
- Services (ClusterIP/NodePort/LoadBalancer, selectors, headless)
- Ingress/Egress & HTTP routing (basic rules, paths, service backends)
- Networking utilities (DNS in-cluster, port-forward, exec, curl)
- Persistence (PVCs, using existing StorageClasses, common volume types)
- Observability & troubleshooting (logs, describe/events, kubectl debug/ephemeral containers)
- Metadata Labels, annotations & selectors (label ops, field selectors, jsonpath)
- Imperative vs declarative (—dry-run, create/apply/edit/replace/patch)
- Container Image & registry use (imagePullPolicy, imagePullSecrets, private registries)
- Security basics (securityContext, runAsUser/fsGroup, capabilities, readOnlyRootFilesystem)
- ServiceAccounts in apps (mounting SA, minimal RBAC needed for app access)
- Scheduling hints (nodeSelector, affinity/anti-affinity, tolerations)
- Namespaces & contexts (scoping resources, default namespace, context switching)
- API discovery & docs (kubectl explain, api-resources, api-versions)

You can simplify the categories when actually using the schema (the examples in the parentheticals just help provide context for the specific types) - a short name is fine, ie ‘linux-command’ ‘core-workload’ ‘routing’ ‘api’ ‘app-config’ ‘pod-design’ et cetera for writing to the yaml and to the sqlite db. Each one of the ‘drill’ sections should open to something looking like this, using either the short name from our schema classification, or the full description for ease of navigation: 

   ○ Linux Syntax(Commands from Vim, Kubectl, Docker ,Helm )  
   ○ Core workloads (Pods, ReplicaSets, Deployments; rollouts/rollbacks)
   ○ Pod design patterns (initContainers, sidecars, lifecycle hooks)
   ○ Commands, args, and env (ENTRYPOINT/CMD overrides, env/envFrom)
   ○ App configuration (ConfigMaps, Secrets, projected & downwardAPI volumes)
   ○ Probes & health (liveness, readiness, startup; graceful shutdown)
   ○ Resource management (requests/limits, QoS classes, HPA basics)
   ○ Jobs & CronJobs (completions, parallelism, backoff, schedules)
   ○ Services (ClusterIP/NodePort/LoadBalancer, selectors, headless)
   ○ Ingress & HTTP routing (basic rules, paths, service backends)
   ○ Networking utilities (DNS in-cluster, port-forward, exec, curl)
   ○ Persistence (PVCs, using existing StorageClasses, common volume types)
   ○ Observability & troubleshooting (logs, describe/events, kubectl debug/ephemeral containers)
   ○ Labels, annotations & selectors (label ops, field selectors, jsonpath)
   ○ Imperative vs declarative (—dry-run, create/apply/edit/replace/patch)
   ○ Image & registry use (imagePullPolicy, imagePullSecrets, private registries)
   ○ Security basics (securityContext, runAsUser/fsGroup, capabilities, readOnlyRootFilesystem)
   ○ ServiceAccounts in apps (mounting SA, minimal RBAC needed for app access)
   ○ Scheduling hints (nodeSelector, affinity/anti-affinity, tolerations)
   ○ Namespaces & contexts (scoping resources, default namespace, context switching)
   ○ API discovery & docs (kubectl explain, api-resources, api-versions) 


It must be easy to add questions, either with a schema that you make very explicit and straightforward to implement, or via AI parsing and reformatting. Never delete questions. If they are problematic, add them to a /triage somewhere for later review. The user should have the option to triage questions in the question menu. Do not confuse this with review. Review should be handled entirely by the app. The user will not have the ability to flag or unflag missed questions; that status can only be changed by answering questions. The user should only be able ‘triage’ questions that may be vexing for reasons that may be beyond the fault of the user.  

Here is what the question menu should look like: 

○ Answer Question
○ Visit Source 
○ Next Question
○ Previous Question
○ Triage
○ Back (returns to previous menu)


Here are some important rules to remember: 
- It must be easy to add new questions. Provide me a schema and I will format, but also be prepared to format for me with AI. 
- AI feedback happens on every single answer. Attempt to explain the necessary answer, 
or simply the subject matter in question for simpler terminology-based questions. 
- Every question that Socratic Mode creates, force it to adhere to the schema, and then store it. Update the metadata table in sqlite after every generation. 
- Every question that the user gets wrong, flag it for review. If they get it right, either in review or if it comes up when running through quiz types, remove it from the flagged list. 
- All of this must be coordinated from a single CLI app.
- We currently do not have any integration with live clusters. The command syntax should be evaluated with a dry-run, as will the manifests. We do have plans for integration with various sandbox environments, clusters, and other learning modules - but do not let them get in the way of the core architecture we have described here.  
- NEVER clear out questions
- the database should only store metadata about the yaml 
- Enrichment should only happen during generation or triage
- Under the settings option ‘AI Provider' the user can change providers, view keys, or change keys   
- The app should inform the user which AI provider they are using, it should recognize if a key has been set in the environment. 
- The only section that is truly available off line is the 'basic' category because technically those can be evaluated literally, without AI       
- Try not to generate repeat or too-similar questions;create a check for this problem. 
-  Make sure it is very easy to just copy and past questions in here and have them show up in the app, in their relevant sections, format them as needed      
- Socratic Mode GENERATES questions

 Tests: 
- make sure you can generate questions of all 4 types and all 21 subjects (81 examples in all) 
- make sure you can add questions and parse/reformat from any type of document 
- make sure you can answer questions in the manner we have specified for each type of question
- test for generated questions to be automatically added to /yaml and tracked by database 
- test that you can delete questions 
- test that you can fix triaged questions 
- test that you do not make duplicate questions
